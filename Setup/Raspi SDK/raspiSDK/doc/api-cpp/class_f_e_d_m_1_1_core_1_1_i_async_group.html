<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>FEDM for C++: FEDM::Core::IAsyncGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="identification.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FEDM for C++
   &#160;<span id="projectnumber">5.6.0 from 2021-05-21</span>
   </div>
   <div id="projectbrief">Class Library for IDENTIFICATION RFID-Readers, manufactured by FEIG ELECTRONIC GmbH</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_f_e_d_m_1_1_core_1_1_i_async_group.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_f_e_d_m_1_1_core_1_1_i_async_group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEDM::Core::IAsyncGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal class providing methods for asynchronous communication.  
 <a href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a722e220eb42fc4ed5b8bc235f0e696d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a722e220eb42fc4ed5b8bc235f0e696d2">StartNotificationTask</a> (unsigned int uiPortNumber, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_notification_listener.html">INotificationListener</a> *pListener, bool bWithAck=false, unsigned int uiAuthentType=<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a864bab0e86ef03be04ec72dffcc8d07c">FEDM::Core::IPortGroup::TRANSMISSION_PLAIN</a>, std::string sAuthentKey=&quot;&quot;)</td></tr>
<tr class="memdesc:a722e220eb42fc4ed5b8bc235f0e696d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to start an internal listener task for notifications sent by one Reader, which must work in Notification-Mode.  <a href="#a722e220eb42fc4ed5b8bc235f0e696d2">More...</a><br /></td></tr>
<tr class="separator:a722e220eb42fc4ed5b8bc235f0e696d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700ae5a0292b9102822441c22de10067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a700ae5a0292b9102822441c22de10067">Stop</a> ()</td></tr>
<tr class="memdesc:a700ae5a0292b9102822441c22de10067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to cancel an internal listener task at once.  <a href="#a700ae5a0292b9102822441c22de10067">More...</a><br /></td></tr>
<tr class="separator:a700ae5a0292b9102822441c22de10067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd8bd1175f043e5ef3d6a4011ecc335"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a7dd8bd1175f043e5ef3d6a4011ecc335">SetKeepAlivePara</a> (bool bEnableKeepAlive, unsigned int uiKeepAliveIdleTime, unsigned int uiKeepAliveProbeCount, unsigned int uiKeepAliveIntervalTime)</td></tr>
<tr class="separator:a7dd8bd1175f043e5ef3d6a4011ecc335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5959237f41307720f848253461bc55a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#ad5959237f41307720f848253461bc55a">StartInventoryTask</a> (unsigned int uiTimeout, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_inventory_listener.html">IInventoryListener</a> *pListener, bool bRepetitive=false, unsigned int uiAuthentType=<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a864bab0e86ef03be04ec72dffcc8d07c">FEDM::Core::IPortGroup::TRANSMISSION_PLAIN</a>, std::string sAuthentKey=&quot;&quot;)</td></tr>
<tr class="memdesc:ad5959237f41307720f848253461bc55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to execute a single or repetitive asynchronous Inventory (only for some IDENTIFICATION Reader)  <a href="#ad5959237f41307720f848253461bc55a">More...</a><br /></td></tr>
<tr class="separator:ad5959237f41307720f848253461bc55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074944110b1cc23103542b06fe41a012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a074944110b1cc23103542b06fe41a012">TriggerInventoryTask</a> ()</td></tr>
<tr class="memdesc:a074944110b1cc23103542b06fe41a012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to continue a repetitive asynchronous Inventory (only for some IDENTIFICATION Reader)  <a href="#a074944110b1cc23103542b06fe41a012">More...</a><br /></td></tr>
<tr class="separator:a074944110b1cc23103542b06fe41a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df1b1aa2584eab03c31a63bfb376667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a5df1b1aa2584eab03c31a63bfb376667">StartScanEventTask</a> (unsigned int uiPortNumber, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_scan_event_listener.html">IScanEventListener</a> *pListener)</td></tr>
<tr class="memdesc:a5df1b1aa2584eab03c31a63bfb376667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to start an internal listener task for scan events sent by a Scanner.  <a href="#a5df1b1aa2584eab03c31a63bfb376667">More...</a><br /></td></tr>
<tr class="separator:a5df1b1aa2584eab03c31a63bfb376667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal class providing methods for asynchronous communication. </p>
<p><b>Description</b><br />
 This class realizes the nested interface with special methods for asynchronous communication for the Reader class <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>.<br />
 Methods of this class can be called with the <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a396f31fab6156c24db22990d40b912fe">IAsync</a> member of <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a722e220eb42fc4ed5b8bc235f0e696d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722e220eb42fc4ed5b8bc235f0e696d2">&#9670;&nbsp;</a></span>StartNotificationTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::StartNotificationTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_notification_listener.html">INotificationListener</a> *&#160;</td>
          <td class="paramname"><em>pListener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWithAck</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em> = <code><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a864bab0e86ef03be04ec72dffcc8d07c">FEDM::Core::IPortGroup::TRANSMISSION_PLAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to start an internal listener task for notifications sent by one Reader, which must work in Notification-Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNumber</td><td>TCP-Port, which listens for notifications </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pListener</td><td>pointer to listener class in application, which must be derived from <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_notification_listener.html" title="Abstract class for providing a listener interface for application classes, handling notification mode...">INotificationListener</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bWithAck</td><td>(disabled by default); when true, an acknowledge protocol is sent to the Reader, when the listener method of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_notification_listener.html" title="Abstract class for providing a listener interface for application classes, handling notification mode...">INotificationListener</a> is finished<br />
 The Reader must be configured to receive this acknowledge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>(disabled by default); Type of authentification, when set to a type of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7dd46a859ab9ffa6b264e65f7b266a91" title="Constant for secured protocol transmission to select the Advanced Encryption Standard (AES) with 128 ...">FEDM::Core::IPortGroup::TRANSMISSION_AES128</a> or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>(disabled by default); Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0) or OK (=0)</dd></dl>
<p><b>Description</b><br />
 A recurring task of applications is inventorying transponders in the antenna field of the reader. Ideally this should run in the background and then tell the application when transponders are in the field or when the notification has arrived. This is precisely the functionality you can implement using the StartNotificationTask method.<br />
 Internally a thread is started which waits for the reply protocol of the reader and provides the reply data to the application using the call of a listener method of abstract class <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_notification_listener.html" title="Abstract class for providing a listener interface for application classes, handling notification mode...">INotificationListener</a>. A task should only be started if the Notification-Mode is integrated and activated in the Reader's firmware. Only TCP/IP communication is supported.<br />
 The task waits for reception of the Buffered Read Mode data and then invokes one of the listener methods. After the method returns, data can immediately be received again by the Reader.<br />
 If no error occurs, the response data are collected in the internal Buffered Read Mode Table and must be requested gradually with <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_brm_table_group.html#ae17bc5378d7b030c3ad85374f3e5adee" title="Get a valid table item, identified by index. ">IBrmTableGroup::GetItemByIndex()</a> In case of transmission errors the listener method is invoked with the error code and the receiving procedure then resumed. If the Keep-Alive option is activated (default setting: activated), then the listener socket is closed automatically after a break of the network cable or after loss of power and is recovered again. This ensures the reliability of the network connection.<br />
</p>
<p><b>Notes</b><br />
</p><ul>
<li>Depending on the Reader setting, large quantities of data may be sent by the Reader in very short time intervals. Without use of a handshake procedure (see system manual for the Reader), data may be lost if the host is not appropriate for the quantity of notifications.<br />
</li>
<li>For Windows systems: check the settings of the Firewall, if notifications are not received. </li>
</ul>

</div>
</div>
<a id="a700ae5a0292b9102822441c22de10067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700ae5a0292b9102822441c22de10067">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to cancel an internal listener task at once. </p>
<dl class="section return"><dt>Returns</dt><dd>error code (&lt;0) or OK (=0)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: a running Inventory task cannot be stopped. </dd></dl>

</div>
</div>
<a id="a7dd8bd1175f043e5ef3d6a4011ecc335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd8bd1175f043e5ef3d6a4011ecc335">&#9670;&nbsp;</a></span>SetKeepAlivePara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::SetKeepAlivePara </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableKeepAlive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiKeepAliveIdleTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiKeepAliveProbeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiKeepAliveIntervalTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to adjust the keep-alive parameters for notification listener tasks</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableKeepAlive</td><td>if true, keep alive option will be enabled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiKeepAliveIdleTime</td><td>wait time in ms for first probe after connection is dropped down<br />
 For Linux: time is rounded up to seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiKeepAliveProbeCount</td><td>only for Linux: number of probes<br />
 For Windows Server 2003, 2000 and XP it is fixed to 5 by Microsoft For Windows Vista and later it is fixed to 10 by Microsoft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiKeepAliveIntervalTime</td><td>wait time in ms between probes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0) or OK (=0)</dd></dl>
<p><b>Description</b><br />
 The keep-alive option is enabled by default and can be adjusted with this method. The parameters are used with the next call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a722e220eb42fc4ed5b8bc235f0e696d2" title="Method to start an internal listener task for notifications sent by one Reader, which must work in No...">StartNotificationTask()</a>.<br />
 Keep-alive parameters of a running task cannot be adjusted.<br />
 Keep-alive is enabled by default with the following settings:<br />
 Keep-alive Idle Time = 500ms<br />
 Keep-alive Probe Count = 5<br />
 Keep-alive Interval Time = 500ms<br />
 </p><dl class="section note"><dt>Note</dt><dd>Parameters must be set in front of the call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a722e220eb42fc4ed5b8bc235f0e696d2" title="Method to start an internal listener task for notifications sent by one Reader, which must work in No...">StartNotificationTask()</a> </dd></dl>

</div>
</div>
<a id="ad5959237f41307720f848253461bc55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5959237f41307720f848253461bc55a">&#9670;&nbsp;</a></span>StartInventoryTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::StartInventoryTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_inventory_listener.html">IInventoryListener</a> *&#160;</td>
          <td class="paramname"><em>pListener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRepetitive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em> = <code><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a864bab0e86ef03be04ec72dffcc8d07c">FEDM::Core::IPortGroup::TRANSMISSION_PLAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to execute a single or repetitive asynchronous Inventory (only for some IDENTIFICATION Reader) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiTimeout</td><td>Timeout (in multiple of 100ms) for waiting for the response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pListener</td><td>pointer to listener class in application, which must be derived from <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_inventory_listener.html" title="Abstract class for providing a listener interface for application classes, handling asynchronous Inve...">IInventoryListener</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRepetitive</td><td>(disabled by default); when true, a repetitive Inventory task is created and continued after each response with <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html#a074944110b1cc23103542b06fe41a012" title="Method to continue a repetitive asynchronous Inventory (only for some IDENTIFICATION Reader) ...">TriggerInventoryTask()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>(disabled by default); Type of authentification, when set to a type of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7dd46a859ab9ffa6b264e65f7b266a91" title="Constant for secured protocol transmission to select the Advanced Encryption Standard (AES) with 128 ...">FEDM::Core::IPortGroup::TRANSMISSION_AES128</a> or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>(disabled by default); Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0) or OK (=0)</dd></dl>
<p><b>Description</b><br />
 The Inventory command is sent to the Reader and the internal thread waits for the transponder response or a timeout.<br />
 </p><dl class="section note"><dt>Note</dt><dd>The task in the Reader cannot be canceled nor any other command can be sent to the Reader until the task is finished. </dd></dl>

</div>
</div>
<a id="a074944110b1cc23103542b06fe41a012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074944110b1cc23103542b06fe41a012">&#9670;&nbsp;</a></span>TriggerInventoryTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::TriggerInventoryTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to continue a repetitive asynchronous Inventory (only for some IDENTIFICATION Reader) </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0) or OK (=0) </dd></dl>

</div>
</div>
<a id="a5df1b1aa2584eab03c31a63bfb376667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df1b1aa2584eab03c31a63bfb376667">&#9670;&nbsp;</a></span>StartScanEventTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IAsyncGroup::StartScanEventTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_scan_event_listener.html">IScanEventListener</a> *&#160;</td>
          <td class="paramname"><em>pListener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to start an internal listener task for scan events sent by a Scanner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNumber</td><td>TCP-Port, which listens for scan events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pListener</td><td>Listener object, which must be derived from <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_scan_event_listener.html" title="Abstract class for providing a listener interface for application classes, handling asynchronous Scan...">IScanEventListener</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0) or OK (=0) <br />
 <br />
<b>Description:</b><br />
 A recurring task of applications is waiting for transponder or barcode data. Ideally, this should run in the background and then tell the application when a transponder or barcode is scanned. This is precisely the functionality you can implement using the startScanEventTask method.<br />
 Internally a thread is started which waits for the data of the Scanner to forward this data to the application using the call of a listener method of interface <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_scan_event_listener.html" title="Abstract class for providing a listener interface for application classes, handling asynchronous Scan...">IScanEventListener</a> <br />
 NOTE: the listener port can handle only one event at the same time.<br />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
		<li class="navelem"><a class="el" href="namespace_f_e_d_m.html">FEDM</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html">IAsyncGroup</a></li>
		<li class="footer">
<!--			Generated on Wed May 26 2021 10:43:46 for FEDM for C++ by
			<a href="http://www.doxygen.org/index.html">
				<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>-->
			C++ Class-Library FEDM  --  Copyright &copy 2000-2019 by FEIG ELECTRONIC GmbH  
			<a href="http://www.feig.de/en/home.html">
				<img class="footer" src="../images/feig_61x31.jpg" alt="www.feig.de"/>
			</a>	
<!--			1.8.13-->
		</li>
	</ul>
</div>
</body>
</html>
