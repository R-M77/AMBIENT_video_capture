<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>FEDM for C++: FEDM::Core::ReaderModule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="identification.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FEDM for C++
   &#160;<span id="projectnumber">5.6.0 from 2021-05-21</span>
   </div>
   <div id="projectbrief">Class Library for IDENTIFICATION RFID-Readers, manufactured by FEIG ELECTRONIC GmbH</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_f_e_d_m_1_1_core_1_1_reader_module.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_f_e_d_m_1_1_core_1_1_reader_module-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEDM::Core::ReaderModule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class ReaderModule is the Reader class.  
 <a href="class_f_e_d_m_1_1_core_1_1_reader_module.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a180d56bf433362d13c32ab9ec1d4fafe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a180d56bf433362d13c32ab9ec1d4fafe">ReaderModule</a> ()</td></tr>
<tr class="memdesc:a180d56bf433362d13c32ab9ec1d4fafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main constructor.  <a href="#a180d56bf433362d13c32ab9ec1d4fafe">More...</a><br /></td></tr>
<tr class="separator:a180d56bf433362d13c32ab9ec1d4fafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4149e93a2bb4640005688423b9695ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ac4149e93a2bb4640005688423b9695ec">ReaderModule</a> (FEDM_ISCReaderModule *pReaderImpl)</td></tr>
<tr class="memdesc:ac4149e93a2bb4640005688423b9695ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constructor.  <a href="#ac4149e93a2bb4640005688423b9695ec">More...</a><br /></td></tr>
<tr class="separator:ac4149e93a2bb4640005688423b9695ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a3d19264db562072109ec418da70c0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ab3a3d19264db562072109ec418da70c0">~ReaderModule</a> ()</td></tr>
<tr class="memdesc:ab3a3d19264db562072109ec418da70c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab3a3d19264db562072109ec418da70c0">More...</a><br /></td></tr>
<tr class="separator:ab3a3d19264db562072109ec418da70c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920ece8a72a1418283ae7d2cced907b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a920ece8a72a1418283ae7d2cced907b1">SetReaderType</a> (unsigned int uiReaderType)</td></tr>
<tr class="memdesc:a920ece8a72a1418283ae7d2cced907b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method to set the Reader Type (for rare cases)  <a href="#a920ece8a72a1418283ae7d2cced907b1">More...</a><br /></td></tr>
<tr class="separator:a920ece8a72a1418283ae7d2cced907b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9a31617fce3e8960aa0ce4816910b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a3f9a31617fce3e8960aa0ce4816910b8">GetReaderHandle</a> (void) const</td></tr>
<tr class="memdesc:a3f9a31617fce3e8960aa0ce4816910b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handle of the libray FEISC.  <a href="#a3f9a31617fce3e8960aa0ce4816910b8">More...</a><br /></td></tr>
<tr class="separator:a3f9a31617fce3e8960aa0ce4816910b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b2e9039a18ebea9411a68ae5984590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a80b2e9039a18ebea9411a68ae5984590">SetReaderHandle</a> (int handle)</td></tr>
<tr class="memdesc:a80b2e9039a18ebea9411a68ae5984590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the FEISC handle in the library.  <a href="#a80b2e9039a18ebea9411a68ae5984590">More...</a><br /></td></tr>
<tr class="separator:a80b2e9039a18ebea9411a68ae5984590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2034eaed95992a0ff5eb142068d82f5f"><td class="memItemLeft" align="right" valign="top">FEDM_ISCReaderModule *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a2034eaed95992a0ff5eb142068d82f5f">GetReaderImpl</a> ()</td></tr>
<tr class="memdesc:a2034eaed95992a0ff5eb142068d82f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlaying reader module (for rare cases)  <a href="#a2034eaed95992a0ff5eb142068d82f5f">More...</a><br /></td></tr>
<tr class="separator:a2034eaed95992a0ff5eb142068d82f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f26a063ca670c88715717c1f9eb67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a7b6f26a063ca670c88715717c1f9eb67">GetLastError</a> ()</td></tr>
<tr class="memdesc:a7b6f26a063ca670c88715717c1f9eb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last error code.  <a href="#a7b6f26a063ca670c88715717c1f9eb67">More...</a><br /></td></tr>
<tr class="separator:a7b6f26a063ca670c88715717c1f9eb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6c924cf4a6b2a79d810f800a8c3bd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a6a6c924cf4a6b2a79d810f800a8c3bd6">GetLastStatus</a> ()</td></tr>
<tr class="memdesc:a6a6c924cf4a6b2a79d810f800a8c3bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last status byte.  <a href="#a6a6c924cf4a6b2a79d810f800a8c3bd6">More...</a><br /></td></tr>
<tr class="separator:a6a6c924cf4a6b2a79d810f800a8c3bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a02655fcff42f7b9ec5b5d5004f5560"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a2a02655fcff42f7b9ec5b5d5004f5560">GetStatusText</a> (unsigned char ucStatus)</td></tr>
<tr class="memdesc:a2a02655fcff42f7b9ec5b5d5004f5560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a text according the given status value.  <a href="#a2a02655fcff42f7b9ec5b5d5004f5560">More...</a><br /></td></tr>
<tr class="separator:a2a02655fcff42f7b9ec5b5d5004f5560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2de9a0bf3621ff33ee901bdf910e43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a7d2de9a0bf3621ff33ee901bdf910e43">Reboot</a> ()</td></tr>
<tr class="memdesc:a7d2de9a0bf3621ff33ee901bdf910e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a hardware reset of the Reader.  <a href="#a7d2de9a0bf3621ff33ee901bdf910e43">More...</a><br /></td></tr>
<tr class="separator:a7d2de9a0bf3621ff33ee901bdf910e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792e7e9aa76bd619a0f956fe74fa0329"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a792e7e9aa76bd619a0f956fe74fa0329">RfReset</a> ()</td></tr>
<tr class="memdesc:a792e7e9aa76bd619a0f956fe74fa0329"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RF-field of the Reader antenna is switched off for a short time with the [0x69] RF Reset command.  <a href="#a792e7e9aa76bd619a0f956fe74fa0329">More...</a><br /></td></tr>
<tr class="separator:a792e7e9aa76bd619a0f956fe74fa0329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33768975cac23502d32b052c3ce0156"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ac33768975cac23502d32b052c3ce0156">RfOff</a> ()</td></tr>
<tr class="memdesc:ac33768975cac23502d32b052c3ce0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RF-field of the Reader antenna is switched off with the [0x6A] RF On/Off command.  <a href="#ac33768975cac23502d32b052c3ce0156">More...</a><br /></td></tr>
<tr class="separator:ac33768975cac23502d32b052c3ce0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e0c4bbebf5f0f5cb166d9fa36150b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ad9e0c4bbebf5f0f5cb166d9fa36150b5">RfOn</a> (unsigned int uiAntennaNo, bool bMaintainHostMode)</td></tr>
<tr class="memdesc:ad9e0c4bbebf5f0f5cb166d9fa36150b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RF-field of the Reader is switsched on with the [0x6A] RF On/Off command.  <a href="#ad9e0c4bbebf5f0f5cb166d9fa36150b5">More...</a><br /></td></tr>
<tr class="separator:ad9e0c4bbebf5f0f5cb166d9fa36150b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68815e2d82b7ac55475484d76b3b658d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a68815e2d82b7ac55475484d76b3b658d">SetOutput</a> (const std::vector&lt; <a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_output_setting.html">Utility::OutputSetting</a> &gt; &amp;vOutputSets)</td></tr>
<tr class="memdesc:a68815e2d82b7ac55475484d76b3b658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command serves temporary limited or unlimited activation of the outputs of the Reader with the [0x72] Set Output command  <a href="#a68815e2d82b7ac55475484d76b3b658d">More...</a><br /></td></tr>
<tr class="separator:a68815e2d82b7ac55475484d76b3b658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeea01e8249b77e1e19776c01519f832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#adeea01e8249b77e1e19776c01519f832">GetInput</a> (unsigned int &amp;input)</td></tr>
<tr class="memdesc:adeea01e8249b77e1e19776c01519f832"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual status of the digital inputs can be determined with the [0x74] Get Input command.  <a href="#adeea01e8249b77e1e19776c01519f832">More...</a><br /></td></tr>
<tr class="separator:adeea01e8249b77e1e19776c01519f832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83569925ad85c29aeb2321ba7f594ad4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a83569925ad85c29aeb2321ba7f594ad4">SetSystemClock</a> (const <a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_date_time.html">Utility::DateTime</a> &amp;dateAndTime)</td></tr>
<tr class="memdesc:a83569925ad85c29aeb2321ba7f594ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Reader's system clock is set  <a href="#a83569925ad85c29aeb2321ba7f594ad4">More...</a><br /></td></tr>
<tr class="separator:a83569925ad85c29aeb2321ba7f594ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02c5532b1267a4090b59cb03df9c1dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#af02c5532b1267a4090b59cb03df9c1dd">GetSystemClock</a> (<a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_date_time.html">Utility::DateTime</a> &amp;dateAndTime)</td></tr>
<tr class="memdesc:af02c5532b1267a4090b59cb03df9c1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query of the Reader's system clock  <a href="#af02c5532b1267a4090b59cb03df9c1dd">More...</a><br /></td></tr>
<tr class="separator:af02c5532b1267a4090b59cb03df9c1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3598f210abbe5c3a80f9c4c9067099"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#afa3598f210abbe5c3a80f9c4c9067099">ReaderLogin</a> (const std::string &amp;password)</td></tr>
<tr class="memdesc:afa3598f210abbe5c3a80f9c4c9067099"><td class="mdescLeft">&#160;</td><td class="mdescRight">A login for access to the Reader's configuration is executed with the [0xA0] Reader Login command.  <a href="#afa3598f210abbe5c3a80f9c4c9067099">More...</a><br /></td></tr>
<tr class="separator:afa3598f210abbe5c3a80f9c4c9067099"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab9a7ef1b446d2ec99bbc0c9751fbee4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html">IPortGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ab9a7ef1b446d2ec99bbc0c9751fbee4c">IPort</a></td></tr>
<tr class="memdesc:ab9a7ef1b446d2ec99bbc0c9751fbee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing port specific methods like ConnectUSB, etc.  <a href="#ab9a7ef1b446d2ec99bbc0c9751fbee4c">More...</a><br /></td></tr>
<tr class="separator:ab9a7ef1b446d2ec99bbc0c9751fbee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb2ea5f2e8510a06d09b9882fac725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_command_group.html">ICommandGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ac5fb2ea5f2e8510a06d09b9882fac725">ICmd</a></td></tr>
<tr class="memdesc:ac5fb2ea5f2e8510a06d09b9882fac725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing Reader command specific methods.  <a href="#ac5fb2ea5f2e8510a06d09b9882fac725">More...</a><br /></td></tr>
<tr class="separator:ac5fb2ea5f2e8510a06d09b9882fac725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626268b1ee257dfc7efb5064e1ba6737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_config_group.html">IConfigGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a626268b1ee257dfc7efb5064e1ba6737">ICfg</a></td></tr>
<tr class="memdesc:a626268b1ee257dfc7efb5064e1ba6737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing Reader configuration specific methods.  <a href="#a626268b1ee257dfc7efb5064e1ba6737">More...</a><br /></td></tr>
<tr class="separator:a626268b1ee257dfc7efb5064e1ba6737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f117cb587e85bcdca913d7915772d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html">IInfoGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a7d5f117cb587e85bcdca913d7915772d">IInfo</a></td></tr>
<tr class="memdesc:a7d5f117cb587e85bcdca913d7915772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing Reader info specific methods.  <a href="#a7d5f117cb587e85bcdca913d7915772d">More...</a><br /></td></tr>
<tr class="separator:a7d5f117cb587e85bcdca913d7915772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228dbcf31b6d3067bf61d9ab8644ad88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_hm_table_group.html">IHmTableGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a228dbcf31b6d3067bf61d9ab8644ad88">IHmTable</a></td></tr>
<tr class="memdesc:a228dbcf31b6d3067bf61d9ab8644ad88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing Host Mode table specific methods. Normally, method interface of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html" title="Internal class providing Transponder specific Reader commands, when the Reader is working in Host Mod...">ITagGroup</a> should be preferred for Transponder communication.  <a href="#a228dbcf31b6d3067bf61d9ab8644ad88">More...</a><br /></td></tr>
<tr class="separator:a228dbcf31b6d3067bf61d9ab8644ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b42e24df91a987f3f6df486947f5ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_brm_table_group.html">IBrmTableGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ac6b42e24df91a987f3f6df486947f5ea">IBrmTable</a></td></tr>
<tr class="memdesc:ac6b42e24df91a987f3f6df486947f5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing Buffered Read Mode table specific methods.  <a href="#ac6b42e24df91a987f3f6df486947f5ea">More...</a><br /></td></tr>
<tr class="separator:ac6b42e24df91a987f3f6df486947f5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f31fab6156c24db22990d40b912fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html">IAsyncGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a396f31fab6156c24db22990d40b912fe">IAsync</a></td></tr>
<tr class="memdesc:a396f31fab6156c24db22990d40b912fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing special methods for asynchronous communication.  <a href="#a396f31fab6156c24db22990d40b912fe">More...</a><br /></td></tr>
<tr class="separator:a396f31fab6156c24db22990d40b912fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e0f9f14a383cfcf08c80844e6de1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_log_group.html">ILogGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a80e0f9f14a383cfcf08c80844e6de1b6">ILog</a></td></tr>
<tr class="memdesc:a80e0f9f14a383cfcf08c80844e6de1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing special methods for logging.  <a href="#a80e0f9f14a383cfcf08c80844e6de1b6">More...</a><br /></td></tr>
<tr class="separator:a80e0f9f14a383cfcf08c80844e6de1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f1e5af11815406b78f57f353ce7cc"><td class="memItemLeft" align="right" valign="top"><a id="a0b6f1e5af11815406b78f57f353ce7cc"></a>
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_key_mng_group.html">IKeyMngGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a0b6f1e5af11815406b78f57f353ce7cc">IKeyMng</a></td></tr>
<tr class="memdesc:a0b6f1e5af11815406b78f57f353ce7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing special methods for key management. <br /></td></tr>
<tr class="separator:a0b6f1e5af11815406b78f57f353ce7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28528e9d0698c87f3c04448547c30ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_fw_upd_group.html">IFwUpdGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a28528e9d0698c87f3c04448547c30ae8">IFwUpd</a></td></tr>
<tr class="memdesc:a28528e9d0698c87f3c04448547c30ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing methods for firmware update.  <a href="#a28528e9d0698c87f3c04448547c30ae8">More...</a><br /></td></tr>
<tr class="separator:a28528e9d0698c87f3c04448547c30ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17837e184f2fdc21bd578acb736b838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html">ITagGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ae17837e184f2fdc21bd578acb736b838">ITag</a></td></tr>
<tr class="memdesc:ae17837e184f2fdc21bd578acb736b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing transponder specific methods like Inventory and Select.  <a href="#ae17837e184f2fdc21bd578acb736b838">More...</a><br /></td></tr>
<tr class="separator:ae17837e184f2fdc21bd578acb736b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb703158d492330f8d15f2fda854881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_ext_device_group.html">IExtDeviceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#aceb703158d492330f8d15f2fda854881">IExtDev</a></td></tr>
<tr class="memdesc:aceb703158d492330f8d15f2fda854881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested interface providing specific methods for external Devices (like Gate People Counter or Function Units)  <a href="#aceb703158d492330f8d15f2fda854881">More...</a><br /></td></tr>
<tr class="separator:aceb703158d492330f8d15f2fda854881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class ReaderModule is the Reader class. </p>
<p><b>Description</b><br />
 This class realizes the uniform Reader class for all IDENTIFICATION Readers and supports all working modes.<br />
 Each physical Reader needs one instance of this class. Multiple connections from one instance to many Readers are not possible. Also an alternating use of one instance for multiple Readers is not recommended.<br />
 This Reader class has a wide method interface, devided in groups for better orientation. The method interfaces of these groups are realized with nested classes.<br />
 <br />
 </p><dl class="section note"><dt>Note</dt><dd>1. It is highly recommended to read the Reader's System Manual when coding the Reader communication. </dd>
<dd>
2. The functionality of this class is implemented with the private embedded class FEDM_ISCReaderModule. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a180d56bf433362d13c32ab9ec1d4fafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180d56bf433362d13c32ab9ec1d4fafe">&#9670;&nbsp;</a></span>ReaderModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReaderModule::ReaderModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main constructor. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ac4149e93a2bb4640005688423b9695ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4149e93a2bb4640005688423b9695ec">&#9670;&nbsp;</a></span>ReaderModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReaderModule::ReaderModule </td>
          <td>(</td>
          <td class="paramtype">FEDM_ISCReaderModule *&#160;</td>
          <td class="paramname"><em>pReaderImpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special constructor. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ab3a3d19264db562072109ec418da70c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a3d19264db562072109ec418da70c0">&#9670;&nbsp;</a></span>~ReaderModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReaderModule::~ReaderModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a920ece8a72a1418283ae7d2cced907b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920ece8a72a1418283ae7d2cced907b1">&#9670;&nbsp;</a></span>SetReaderType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::SetReaderType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiReaderType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method to set the Reader Type (for rare cases) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiReaderType</td><td>Reader Type Number from namespace <a class="el" href="class_f_e_d_m_1_1_core_1_1_const_1_1_reader_type.html" title="Namespace with all Reader Type Numbers. ">FEDM::Core::Const::ReaderType</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 The Reader Type Number is essential for the Reader class and is set normally within one of the Connect methods of the nested interface <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html" title="Internal class providing communication port specific commands. ">IPortGroup</a>.<br />
 In rare cases, when the Reader Type Number must be set in front of a connection, this method can be used. </p>

</div>
</div>
<a id="a3f9a31617fce3e8960aa0ce4816910b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9a31617fce3e8960aa0ce4816910b8">&#9670;&nbsp;</a></span>GetReaderHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::GetReaderHandle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the handle of the libray FEISC. </p>
<dl class="section return"><dt>Returns</dt><dd>handle of FEISC object</dd></dl>
<p><b>Description</b><br />
 This method is useful in rare cases.<br />
 The underlaying library FEISC prepares or evaluates the communication frames and controls the communication with one active port layer library, which is selected with one of the Connect methods in <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html" title="Internal class providing communication port specific commands. ">IPortGroup</a>.<br />
 With knowledge of this handle one can communicate with the same Reader but with FEISC functions. </p>

</div>
</div>
<a id="a80b2e9039a18ebea9411a68ae5984590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b2e9039a18ebea9411a68ae5984590">&#9670;&nbsp;</a></span>SetReaderHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReaderModule::SetReaderHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the FEISC handle in the library. </p>
<p><b>Description</b><br />
 This method is useful in rare cases.<br />
 The underlaying library FEISC prepares or evaluates the communication frames and controls the communication with one active port layer library.<br />
 The Connect methods in <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html" title="Internal class providing communication port specific commands. ">IPortGroup</a> cannot be used. Instead of, the communication must be established with the specific port layer library and the connection between the port layer library and FEISC must be handled in the application.<br />
 More information can be found in the manual of FEISC. </p>

</div>
</div>
<a id="a2034eaed95992a0ff5eb142068d82f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2034eaed95992a0ff5eb142068d82f5f">&#9670;&nbsp;</a></span>GetReaderImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FEDM_ISCReaderModule * ReaderModule::GetReaderImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the underlaying reader module (for rare cases) </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer of implementation object of type FEDM_ISCReaderModule</dd></dl>
<p><b>Description</b><br />
 The ReaderModule class aggregates the class FEDM_ISCReaderModule, which implements the complete functionality (together with base classes, helper classes and function libraries). FEDM_ISCReaderModule is extended over a lot of years, the complexity is increased extremely and to get a quick overview is difficult. Therefore, this new thin C++ API was born.<br />
 In rare cases, when a special detail needs to be addressed, the pointer of the implementation object can be returned and the old API can be used in parallel with the class ReaderModule. </p>

</div>
</div>
<a id="a7b6f26a063ca670c88715717c1f9eb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f26a063ca670c88715717c1f9eb67">&#9670;&nbsp;</a></span>GetLastError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::GetLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last error code. </p>
<dl class="section return"><dt>Returns</dt><dd>last <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 In cases, when the result of a method is not as expected and it does not return an error code, the application should call this method first to evaluate an internal error. If this method returns OK (=0), then the application should call <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a6a6c924cf4a6b2a79d810f800a8c3bd6" title="Get the last status byte. ">GetLastStatus()</a> to evaluate the returned status byte from the last Reader response. </p>

</div>
</div>
<a id="a6a6c924cf4a6b2a79d810f800a8c3bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6c924cf4a6b2a79d810f800a8c3bd6">&#9670;&nbsp;</a></span>GetLastStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::GetLastStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last status byte. </p>
<dl class="section return"><dt>Returns</dt><dd>status byte from last Reader response. See Reader's System Manual for the full list with all status bytes.</dd></dl>
<p><b>Description</b><br />
 The method ICmdGroup::SendProtocol returns always the status byte of the responded Reader protocol. Thus, the evaluation of the Reader response can be done</p><ul>
<li>and this is strongly recommended - after the method call. But in cases, when the result of a method is not as expected and it does not return an error code, the application should call <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a7b6f26a063ca670c88715717c1f9eb67" title="Get the last error code. ">GetLastError()</a> first to evaluate an internal error. If this method returns OK (=0), then the application should call GetLastStatus() to evaluate the returned status byte from the last Reader response. </li>
</ul>

</div>
</div>
<a id="a2a02655fcff42f7b9ec5b5d5004f5560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a02655fcff42f7b9ec5b5d5004f5560">&#9670;&nbsp;</a></span>GetStatusText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ReaderModule::GetStatusText </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a text according the given status value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucStatus</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Message text for Reader status byte</dd></dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a7d2de9a0bf3621ff33ee901bdf910e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2de9a0bf3621ff33ee901bdf910e43">&#9670;&nbsp;</a></span>Reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::Reboot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a hardware reset of the Reader. </p>
<p><b>Description:</b><br />
 Dependent on the connected Reader type, the reboot is executed as a [0x63] CPU Reset or as a [0x64] System Reset.<br />
 The Reader sends the response protocol at once and executes then the reboot.<br />
 This means, that a Host system must wait until the Reader is rebooted before any further communication is proceeded. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>
<p><b>Important Notes for USB connection:</b><br />
 In case of a USB connection the Reader executes a new enumeration after receiving this command.<br />
 The current USB connection is refreshed internally and the Host must not reopen the connection again.<br />
 <br />
 <b>Important Notes for TCP connection:</b><br />
 In case of a TCP connection the current connection is closed inside the Reader and the host system must reopen the connection again.<br />
 </p>

</div>
</div>
<a id="a792e7e9aa76bd619a0f956fe74fa0329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792e7e9aa76bd619a0f956fe74fa0329">&#9670;&nbsp;</a></span>RfReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::RfReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The RF-field of the Reader antenna is switched off for a short time with the [0x69] RF Reset command. </p>
<p><b>Description:</b><br />
 The RF-field of the Reader antenna is switched off for a few milliseconds. This time differs from Reader to Reader.<br />
 The response of this command will be send after the RF-Reset was completed.<br />
 All Transponders which are within the antenna field of the Reader will be reset to their reset state.<br />
 </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>

</div>
</div>
<a id="ac33768975cac23502d32b052c3ce0156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33768975cac23502d32b052c3ce0156">&#9670;&nbsp;</a></span>RfOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::RfOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The RF-field of the Reader antenna is switched off with the [0x6A] RF On/Off command. </p>
<p><b>Description:</b><br />
 The RF-field of the Reader antenna is switched off.<br />
 If the reader works in an Auto Read Mode (Buffered Read Mode, Scan Mode, Notification Mode or Access Mode), the RF communication is interrupted.<br />
 After the Rf-field is switched off, the Reader accepts every Host command and the RF communication is handled on the last selected antenna.<br />
 For selecting a specific antenna without continuing the Auto Read Mode, use <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ad9e0c4bbebf5f0f5cb166d9fa36150b5" title="The RF-field of the Reader is switsched on with the [0x6A] RF On/Off command. ">RfOn</a> and set the parameter maintainHostMode to true.<br />
 </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>
<p><b>Note for UHF Reader:</b><br />
 A command to reset the persistance flags of Transponders is sent before the Rf-field is switched off. </p>

</div>
</div>
<a id="ad9e0c4bbebf5f0f5cb166d9fa36150b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e0c4bbebf5f0f5cb166d9fa36150b5">&#9670;&nbsp;</a></span>RfOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::RfOn </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAntennaNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMaintainHostMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The RF-field of the Reader is switsched on with the [0x6A] RF On/Off command. </p>
<p><b>Description:</b><br />
 The RF-field of the Reader antenna is switched on.<br />
 If the reader works in an Auto Read Mode (Buffered Read Mode, Scan Mode, Notification Mode or Access Mode), the RF communication is continued with the selected antennaNo (&gt;0) and when maintainHostMode is set to false.<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiAntennaNo</td><td>Number of antenna to be selected to after Rf is switched on (&gt; 0 and limited by the capabilities of the Reader)</td></tr>
    <tr><td class="paramname">bMaintainHostMode</td><td>Applicable only for Auto Read Mode: if true, Host Mode is maintained and the antenna, selected by antennaNo, is switched on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>

</div>
</div>
<a id="a68815e2d82b7ac55475484d76b3b658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68815e2d82b7ac55475484d76b3b658d">&#9670;&nbsp;</a></span>SetOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::SetOutput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_output_setting.html">Utility::OutputSetting</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vOutputSets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command serves temporary limited or unlimited activation of the outputs of the Reader with the [0x72] Set Output command </p>
<p><b>Description:</b><br />
 Each output takes the state defined by OutputSetting for the period of time.<br />
 Each new call of SetOutput overwrites the current output states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vOutputSets</td><td>Dictionary with OutputSetting. The number and type of outputs differs from Reader to Reader.<br />
 The output number is the key and the setting is the value of the dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>
<p><b>Notes:</b><br />
 To reset a continuously activation time, send settings for the respectively output with the activation time of 1.<br />
 A reboot of the Reader resets all activated outputs to its idle state. </p>

</div>
</div>
<a id="adeea01e8249b77e1e19776c01519f832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeea01e8249b77e1e19776c01519f832">&#9670;&nbsp;</a></span>GetInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::GetInput </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual status of the digital inputs can be determined with the [0x74] Get Input command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Flags with the status of each input. Bit 0 for input 1, bit 1 for input 2 and so forth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>

</div>
</div>
<a id="a83569925ad85c29aeb2321ba7f594ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83569925ad85c29aeb2321ba7f594ad4">&#9670;&nbsp;</a></span>SetSystemClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::SetSystemClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_date_time.html">Utility::DateTime</a> &amp;&#160;</td>
          <td class="paramname"><em>dateAndTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Reader's system clock is set </p>
<p><b>Description:</b><br />
 Dependent on the connected Reader type, the system clock is set with a [0x85] Set System Timer command or with [0x87] Set System Time and Date command.<br />
 The first command sets only the internal timer while the second command sets the date and time.<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dateAndTime</td><td>Clock structure with date and time information to be set to in the Reader.<br />
 For the [0x85] Set System Timer, only the time information is applicable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>
<p><b>Note for Auto Read Mode:</b><br />
 After setting the system clock, a [0x33] Initialize Buffer command (<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_brm_table_group.html#a28cea3308f6b3dee1c0bac642c546a9d" title="Initialize of the Reader&#39;s internal data buffer with [0x33] Initialize Buffer command. ">IBrmTableGroup.InitializeBuffer</a>) is necessary to restart the Auto Read Mode with correct time information. </p>

</div>
</div>
<a id="af02c5532b1267a4090b59cb03df9c1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02c5532b1267a4090b59cb03df9c1dd">&#9670;&nbsp;</a></span>GetSystemClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::GetSystemClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_utility_1_1_date_time.html">Utility::DateTime</a> &amp;&#160;</td>
          <td class="paramname"><em>dateAndTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query of the Reader's system clock </p>
<p><b>Description:</b><br />
 Dependent on the connected Reader type, the system clock is queried with a [0x86] Get System Timer command or with [0x88] Get System Time and Date command.<br />
 The first command gets only the internal timer while the second command gets the date and time.<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dateAndTime</td><td>Clock structure with date and time information from the Reader.<br />
 For the [0x86] Get System Timer, only the time information is set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>

</div>
</div>
<a id="afa3598f210abbe5c3a80f9c4c9067099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3598f210abbe5c3a80f9c4c9067099">&#9670;&nbsp;</a></span>ReaderLogin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReaderModule::ReaderLogin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A login for access to the Reader's configuration is executed with the [0xA0] Reader Login command. </p>
<p><b>Description:</b><br />
 A password can protect the configuration parameters from any read and write access, when it is configured in the Reader's configuration with (ReaderConfig.AccessProtection.password).<br />
 A logout can be performed with any false password or with a <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#a7d2de9a0bf3621ff33ee901bdf910e43" title="Executes a hardware reset of the Reader. ">Reboot</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Password with 4 byte length. Use Utility.HexConvert.byteArrayToHexString(byte[]) to convert the given password into a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
<p class="enddd"><b>It is strongly recommended to evaluate always the return value in the application.</b> </p>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab9a7ef1b446d2ec99bbc0c9751fbee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a7ef1b446d2ec99bbc0c9751fbee4c">&#9670;&nbsp;</a></span>IPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html">IPortGroup</a> FEDM::Core::ReaderModule::IPort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing port specific methods like ConnectUSB, etc. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ac5fb2ea5f2e8510a06d09b9882fac725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb2ea5f2e8510a06d09b9882fac725">&#9670;&nbsp;</a></span>ICmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_command_group.html">ICommandGroup</a> FEDM::Core::ReaderModule::ICmd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing Reader command specific methods. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a626268b1ee257dfc7efb5064e1ba6737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626268b1ee257dfc7efb5064e1ba6737">&#9670;&nbsp;</a></span>ICfg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_config_group.html">IConfigGroup</a> FEDM::Core::ReaderModule::ICfg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing Reader configuration specific methods. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a7d5f117cb587e85bcdca913d7915772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5f117cb587e85bcdca913d7915772d">&#9670;&nbsp;</a></span>IInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html">IInfoGroup</a> FEDM::Core::ReaderModule::IInfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing Reader info specific methods. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a228dbcf31b6d3067bf61d9ab8644ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228dbcf31b6d3067bf61d9ab8644ad88">&#9670;&nbsp;</a></span>IHmTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_hm_table_group.html">IHmTableGroup</a> FEDM::Core::ReaderModule::IHmTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing Host Mode table specific methods. Normally, method interface of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html" title="Internal class providing Transponder specific Reader commands, when the Reader is working in Host Mod...">ITagGroup</a> should be preferred for Transponder communication. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ac6b42e24df91a987f3f6df486947f5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b42e24df91a987f3f6df486947f5ea">&#9670;&nbsp;</a></span>IBrmTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_brm_table_group.html">IBrmTableGroup</a> FEDM::Core::ReaderModule::IBrmTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing Buffered Read Mode table specific methods. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a396f31fab6156c24db22990d40b912fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396f31fab6156c24db22990d40b912fe">&#9670;&nbsp;</a></span>IAsync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_async_group.html">IAsyncGroup</a> FEDM::Core::ReaderModule::IAsync</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing special methods for asynchronous communication. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a80e0f9f14a383cfcf08c80844e6de1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e0f9f14a383cfcf08c80844e6de1b6">&#9670;&nbsp;</a></span>ILog</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_log_group.html">ILogGroup</a> FEDM::Core::ReaderModule::ILog</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing special methods for logging. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a28528e9d0698c87f3c04448547c30ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28528e9d0698c87f3c04448547c30ae8">&#9670;&nbsp;</a></span>IFwUpd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_fw_upd_group.html">IFwUpdGroup</a> FEDM::Core::ReaderModule::IFwUpd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing methods for firmware update. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ae17837e184f2fdc21bd578acb736b838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17837e184f2fdc21bd578acb736b838">&#9670;&nbsp;</a></span>ITag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html">ITagGroup</a> FEDM::Core::ReaderModule::ITag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing transponder specific methods like Inventory and Select. </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="aceb703158d492330f8d15f2fda854881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb703158d492330f8d15f2fda854881">&#9670;&nbsp;</a></span>IExtDev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_ext_device_group.html">IExtDeviceGroup</a> FEDM::Core::ReaderModule::IExtDev</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nested interface providing specific methods for external Devices (like Gate People Counter or Function Units) </p>
<p><b>Description</b><br />
 </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
		<li class="navelem"><a class="el" href="namespace_f_e_d_m.html">FEDM</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html">ReaderModule</a></li>
		<li class="footer">
<!--			Generated on Wed May 26 2021 10:43:48 for FEDM for C++ by
			<a href="http://www.doxygen.org/index.html">
				<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>-->
			C++ Class-Library FEDM  --  Copyright &copy 2000-2019 by FEIG ELECTRONIC GmbH  
			<a href="http://www.feig.de/en/home.html">
				<img class="footer" src="../images/feig_61x31.jpg" alt="www.feig.de"/>
			</a>	
<!--			1.8.13-->
		</li>
	</ul>
</div>
</body>
</html>
