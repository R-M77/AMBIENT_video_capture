<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>FEDM for C++: FEDM::Core::ITagGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="identification.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FEDM for C++
   &#160;<span id="projectnumber">5.6.0 from 2021-05-21</span>
   </div>
   <div id="projectbrief">Class Library for IDENTIFICATION RFID-Readers, manufactured by FEIG ELECTRONIC GmbH</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_f_e_d_m_1_1_core_1_1_i_tag_group.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_f_e_d_m_1_1_core_1_1_i_tag_group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEDM::Core::ITagGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal class providing Transponder specific Reader commands, when the Reader is working in Host Mode.  
 <a href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4a831c0f7b61c7ba6f36de45b6461d2b"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">FEDM::Core::TagHandler::TH_Base</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">TH_LIST</a></td></tr>
<tr class="memdesc:a4a831c0f7b61c7ba6f36de45b6461d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a map type with detected TagHandlers after <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646" title="Method executes synchronous Inventory command (for all IDENTIFICATION Readers) ">ITagGroup::Inventory</a>.  <a href="#a4a831c0f7b61c7ba6f36de45b6461d2b">More...</a><br /></td></tr>
<tr class="separator:a4a831c0f7b61c7ba6f36de45b6461d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d50b7cf7c2705a012b3e091f61943fd"><td class="memItemLeft" align="right" valign="top"><a id="a6d50b7cf7c2705a012b3e091f61943fd"></a>
typedef std::map&lt; std::string, <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">FEDM::Core::TagHandler::TH_Base</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a6d50b7cf7c2705a012b3e091f61943fd">TH_LIST_ITOR</a></td></tr>
<tr class="memdesc:a6d50b7cf7c2705a012b3e091f61943fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an iterator for map type with detected Taghandlers after <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646" title="Method executes synchronous Inventory command (for all IDENTIFICATION Readers) ">ITagGroup::Inventory</a>. <br /></td></tr>
<tr class="separator:a6d50b7cf7c2705a012b3e091f61943fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedebf19db0105df374127762ebf62646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646">Inventory</a> (bool bAll=true, unsigned char ucMode=0x00, unsigned char ucAntennas=1)</td></tr>
<tr class="memdesc:aedebf19db0105df374127762ebf62646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method executes synchronous Inventory command (for all IDENTIFICATION Readers)  <a href="#aedebf19db0105df374127762ebf62646">More...</a><br /></td></tr>
<tr class="separator:aedebf19db0105df374127762ebf62646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a090506007d7222d113c991129acbe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">TH_LIST</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#ae5a090506007d7222d113c991129acbe">GetTagList</a> ()</td></tr>
<tr class="memdesc:ae5a090506007d7222d113c991129acbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return of the Transponder list previous built with Inventory.  <a href="#ae5a090506007d7222d113c991129acbe">More...</a><br /></td></tr>
<tr class="separator:ae5a090506007d7222d113c991129acbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0eb6773b59f6601cfc0a17770c3da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#abe0eb6773b59f6601cfc0a17770c3da0">Select</a> (<a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> *pTagHandler, unsigned int uiTagDriver=0)</td></tr>
<tr class="memdesc:abe0eb6773b59f6601cfc0a17770c3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for executing a synchronous Select command (for all IDENTIFICATION Readers, if supported by the applied standard)  <a href="#abe0eb6773b59f6601cfc0a17770c3da0">More...</a><br /></td></tr>
<tr class="separator:abe0eb6773b59f6601cfc0a17770c3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0089c5f2259d8a32ac917bba6e3c36fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a0089c5f2259d8a32ac917bba6e3c36fe">GetSelectedTagHandler</a> ()</td></tr>
<tr class="memdesc:a0089c5f2259d8a32ac917bba6e3c36fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Transponder object, which is in the selected state.  <a href="#a0089c5f2259d8a32ac917bba6e3c36fe">More...</a><br /></td></tr>
<tr class="separator:a0089c5f2259d8a32ac917bba6e3c36fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d1677a7ac84ed3e40adcd55565aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#ace5d1677a7ac84ed3e40adcd55565aa5">GetTagHandler</a> (std::string sIDD)</td></tr>
<tr class="memdesc:ace5d1677a7ac84ed3e40adcd55565aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Transponder object from the Transponder list, identified by the Identifier Data (IDD), resp. UID, resp. EPC, resp. SNR of Transponder.  <a href="#ace5d1677a7ac84ed3e40adcd55565aa5">More...</a><br /></td></tr>
<tr class="separator:ace5d1677a7ac84ed3e40adcd55565aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11ee9dfbeafbf1df8dc9ad2262d74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a8f11ee9dfbeafbf1df8dc9ad2262d74f">CreateNonAddressedTagHandler</a> (unsigned int uiTagHandlerType)</td></tr>
<tr class="memdesc:a8f11ee9dfbeafbf1df8dc9ad2262d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Transponder object for working in non-addressed mode.  <a href="#a8f11ee9dfbeafbf1df8dc9ad2262d74f">More...</a><br /></td></tr>
<tr class="separator:a8f11ee9dfbeafbf1df8dc9ad2262d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal class providing Transponder specific Reader commands, when the Reader is working in Host Mode. </p>
<p><b>Description</b><br />
 This class realizes the nested interface with transponder specific methods like Inventory and Select for the Reader class <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>.<br />
 The communication with Transponders is realized with <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> classes, which will be served with methods of this class.<br />
 Methods of this class can be called with the <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ae17837e184f2fdc21bd578acb736b838">ITag</a> member of <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>.<br />
 <br />
 The concept of TagHandler classes provides an efficient programming interface with different transponder types. It is based on the automatic identification of the type of the transponder after a successful inventory. With ISO 15693 compliant transponders the manufacturer ID and the chipID, which are part of the serial number, are evaluated. With ISO 14443 compliant transponders the type of the TagHandler can be determined after a mandatory Select command based on the returned Card-Info or, in case of the explicit selection of a transponder driver with the Select comand, the transponder driver selects the type of the TagHandler.<br />
 All TagHandler classes are derived from the base class <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html" title="Transponder class providing basic commands for all Transponders. ">TagHandler::TH_Base</a>. Furthermore, the relationship between the different transponder types is maped to derivations between TagHandler classes.<br />
 TagHandler classes are created, managed and deleted internally. After each call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646" title="Method executes synchronous Inventory command (for all IDENTIFICATION Readers) ">Inventory()</a>, the Reader class checks the present state of each TagHandler and removes the handler if the dedicated transponder is out of field. Thus, the life cycle of a TagHandler is normally one inventory cycle. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4a831c0f7b61c7ba6f36de45b6461d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a831c0f7b61c7ba6f36de45b6461d2b">&#9670;&nbsp;</a></span>TH_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">FEDM::Core::TagHandler::TH_Base</a>*&gt; <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">FEDM::Core::ITagGroup::TH_LIST</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a map type with detected TagHandlers after <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646" title="Method executes synchronous Inventory command (for all IDENTIFICATION Readers) ">ITagGroup::Inventory</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>IID of the Transponder </td></tr>
    <tr><td class="paramname">FEDM::Core::TagHandler::TH_Base*</td><td>Pointer to the <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> object, casted to base class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aedebf19db0105df374127762ebf62646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedebf19db0105df374127762ebf62646">&#9670;&nbsp;</a></span>Inventory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ITagGroup::Inventory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAll</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucMode</em> = <code>0x00</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucAntennas</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method executes synchronous Inventory command (for all IDENTIFICATION Readers) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bAll</td><td>when true (preset), Inventory is repeated as long as the Reader respond MORE status </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMode</td><td>MODE byte (Preset with 0) to adjust the Inventory. See Reader's System Manual for additional information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucAntennas</td><td>Antenna Flag field to select specific antenna(s). Only available for Readers with internal Multiplexer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Call of an Inventory and collecting all found tags in a TagList of type TagHandler base class <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TH_Base</a>.<br />
 If successful, the list can be called with <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#ae5a090506007d7222d113c991129acbe">GetTagList</a><br />
 If applicable, the returned Transponder information is analyzed and the dedicated TagHandler class is created. In all other cases, the TagHandler base class is created.</p>
<p><br />
<b>Example:</b> The following example demonstrates the principle work with Inventory, how to identify the returned TagHandler types and how to work with the Transponder objects.<br />
 </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_f_e_d_m_1_1_core.html">FEDM::Core</a>;</div><div class="line"></div><div class="line"><a class="code" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">ITagGroup::TH_LIST</a>* pTagList = NULL;</div><div class="line"><a class="code" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a6d50b7cf7c2705a012b3e091f61943fd">ITagGroup::TH_LIST_ITOR</a> itor;</div><div class="line"><a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a>* pTH = NULL;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> ret = reader.ITag.Inventory();</div><div class="line"><span class="keywordflow">if</span>(ret)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(ret &lt; 0)</div><div class="line">    {</div><div class="line">        <span class="comment">// we have an internal error</span></div><div class="line">        cout &lt;&lt; reader.GetErrorText(ret);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// we have a feedback from the Reader, signaling a problem</span></div><div class="line">        cout &lt;&lt; reader.GetStatusText(ret);</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">ITagGroup::TH_LIST</a>&amp; TagList = reader.ITag.GetTagList();</div><div class="line"></div><div class="line">    <span class="comment">// iteration loop over all detected Transponders</span></div><div class="line">    <span class="keywordflow">for</span>( itor = TagList.begin(); itor != pTagList.end(); itor++ )</div><div class="line">    {</div><div class="line">        pTH = itor-&gt;second;</div><div class="line"></div><div class="line">        <span class="comment">// is selected Transponder of standard ISO 14443-4?</span></div><div class="line">        <span class="keywordflow">if</span>(dynamic_cast&lt;TagHandler::TH_ISO14443_4*&gt;(pTH) != NULL)</div><div class="line">        {</div><div class="line">            <a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443__4.html">TagHandler::TH_ISO14443_4</a>* pTH_14443_4 = (<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443__4.html">TagHandler::TH_ISO14443_4</a>*)pTH;</div><div class="line"></div><div class="line">            <span class="comment">// use of casted TagHandler</span></div><div class="line">            cout &lt;&lt; pTH_14443_4-&gt;<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443.html#abd826051767bc98c128d36cbba8ba222">GetManufacturerName</a>();</div><div class="line">        }</div><div class="line">        <span class="comment">// is selected Transponder of standard ISO 15693?</span></div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dynamic_cast&lt;TagHandler::TH_ISO15693*&gt;(pTH) != NULL)</div><div class="line">        {</div><div class="line">            <a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html">TagHandler::TH_ISO15693</a>* pTH_15693 = (<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html">TagHandler::TH_ISO15693</a>*)pTH;</div><div class="line"></div><div class="line">            <span class="comment">// use of casted TagHandler</span></div><div class="line">            cout &lt;&lt; pTH_15693-&gt;<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html#a70cfdfa7c32a50874d54422411f958ec">GetManufacturerName</a>();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">NOTE: reader is an <span class="keywordtype">object</span> of type <a class="code" href="class_f_e_d_m_1_1_core_1_1_reader_module.html">FEDM::Core::ReaderModule</a></div></div><!-- fragment --> 
</div>
</div>
<a id="ae5a090506007d7222d113c991129acbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a090506007d7222d113c991129acbe">&#9670;&nbsp;</a></span>GetTagList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a4a831c0f7b61c7ba6f36de45b6461d2b">TH_LIST</a>&amp; FEDM::Core::ITagGroup::GetTagList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return of the Transponder list previous built with Inventory. </p>
<dl class="section return"><dt>Returns</dt><dd>List with all previously detected Transponder objects (<a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> classes) or an empty list</dd></dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="abe0eb6773b59f6601cfc0a17770c3da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0eb6773b59f6601cfc0a17770c3da0">&#9670;&nbsp;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ITagGroup::Select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> *&#160;</td>
          <td class="paramname"><em>pTagHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiTagDriver</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for executing a synchronous Select command (for all IDENTIFICATION Readers, if supported by the applied standard) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTagHandler</td><td>Pointer to <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> object from last <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#aedebf19db0105df374127762ebf62646" title="Method executes synchronous Inventory command (for all IDENTIFICATION Readers) ">Inventory()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiTagDriver</td><td>For manual selection of one special Transponder driver to be applied to in the Reader (only for some IDENTIFICATION Readers) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Call of a Select command. For ISO 14443 Transponders, if applicable, the <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> class successive called with <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a0089c5f2259d8a32ac917bba6e3c36fe">GetSelectedTagHandler</a> is modified. Another Transponder, which is in the selected state will be switched to the idle state and the specified Transponder (in pTagHandler) is switched to the selected state.</p>
<dl class="section note"><dt>Note</dt><dd>See the following example how to identify the returned TagHandler type and how to work with the Transponder object.<br />
 <br />
 </dd></dl>
<p><br />
<b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_f_e_d_m_1_1_core.html">FEDM::Core</a>;</div><div class="line"></div><div class="line"><a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a>* pTH = NULL;</div><div class="line"></div><div class="line">pTH = reader.ITag.GetTagHandler(<span class="stringliteral">&quot;0123456789ABCDEF&quot;</span>);</div><div class="line"><span class="keywordtype">int</span> ret = reader.ITag.Select(pTH);</div><div class="line"><span class="keywordflow">if</span>(ret &lt; 0)</div><div class="line">{</div><div class="line">    <span class="comment">// we have an internal error</span></div><div class="line">    cout &lt;&lt; reader.GetErrorText(ret);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(ret &gt; 0)</div><div class="line">{</div><div class="line">    <span class="comment">// we have a feedback from the Reader, signaling a problem</span></div><div class="line">    cout &lt;&lt; reader.GetStatusText(ret);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    pTH = <a class="code" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#a0089c5f2259d8a32ac917bba6e3c36fe">GetSelectedTagHandler</a>();</div><div class="line"></div><div class="line">    <span class="comment">// inherited type of pTH can now be modified !!</span></div><div class="line"></div><div class="line">    <span class="comment">// is selected Transponder of standard ISO 14443-4?</span></div><div class="line">    <span class="keywordflow">if</span>(dynamic_cast&lt;TagHandler::TH_ISO14443_4*&gt;(pTH) != NULL)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443__4.html">TagHandler::TH_ISO14443_4</a>* pTH_14443_4 = (<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443__4.html">TagHandler::TH_ISO14443_4</a>*)pTH;</div><div class="line"></div><div class="line">        <span class="comment">// use of casted TagHandler</span></div><div class="line">        cout &lt;&lt; pTH_14443_4-&gt;<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o14443.html#abd826051767bc98c128d36cbba8ba222">GetManufacturerName</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">NOTE: reader is an <span class="keywordtype">object</span> of type <a class="code" href="class_f_e_d_m_1_1_core_1_1_reader_module.html">FEDM::Core::ReaderModule</a></div></div><!-- fragment --> 
</div>
</div>
<a id="a0089c5f2259d8a32ac917bba6e3c36fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0089c5f2259d8a32ac917bba6e3c36fe">&#9670;&nbsp;</a></span>GetSelectedTagHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> * ITagGroup::GetSelectedTagHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Transponder object, which is in the selected state. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> object, which represents a Transponder in selected state (down-casted to base TagHandler class)<br />
 or NULL, if no tag is in selected state</dd></dl>
<p><b>Description</b><br />
 This method returns the <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a>, which is in the selected state. The Transponder in the field must be previously selected with the call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html#abe0eb6773b59f6601cfc0a17770c3da0">Select</a> </p>

</div>
</div>
<a id="ace5d1677a7ac84ed3e40adcd55565aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5d1677a7ac84ed3e40adcd55565aa5">&#9670;&nbsp;</a></span>GetTagHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> * ITagGroup::GetTagHandler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sIDD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Transponder object from the Transponder list, identified by the Identifier Data (IDD), resp. UID, resp. EPC, resp. SNR of Transponder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sIDD</td><td>Identifier Data (IDD), resp. UID, resp. EPC, resp. SNR of Transponder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> object of actual Tag List (down-casted to base TagHandler class)<br />
 or NULL, if IDD could not be found in the Tag List </dd></dl>

</div>
</div>
<a id="a8f11ee9dfbeafbf1df8dc9ad2262d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f11ee9dfbeafbf1df8dc9ad2262d74f">&#9670;&nbsp;</a></span>CreateNonAddressedTagHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a> * ITagGroup::CreateNonAddressedTagHandler </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiTagHandlerType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Transponder object for working in non-addressed mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiTagHandlerType</td><td>Specifies the <a class="el" href="namespace_f_e_d_m_1_1_core_1_1_tag_handler.html" title="Namespace for Transponder classes. ">TagHandler</a> class, for which a TagHandler object for non-addressed communication should be created to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new created TagHandler object (down-casted to base TagHandler class)<br />
 or NULL<br />
<ul>
<li>if TagHandler type does not support non-addressed communication</li>
<li>if TagHandler type could not be identified</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 A list of all TagHandler type constants can be found in <a class="el" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html" title="Transponder class providing basic commands for all Transponders. ">TagHandler::TH_Base</a></p>
<dl class="section note"><dt>Note</dt><dd>See the following example how to identify the returned TagHandler type and how to work with the Transponder object.<br />
 <br />
 </dd></dl>
<p><br />
<b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_f_e_d_m_1_1_core.html">FEDM::Core</a>;</div><div class="line"></div><div class="line"><a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html">TagHandler::TH_Base</a>* pTH = NULL;</div><div class="line"></div><div class="line">pTH = reader.ITag.CreateNonAddressedTagHandler(<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___base.html#adac7c9c20e4c394c6ec15d43e1fe1f93">TagHandler::TH_Base::TYPE_ISO15693</a>);</div><div class="line"><span class="keywordflow">if</span>(pTH == NULL)</div><div class="line">{</div><div class="line">    <span class="comment">// we have an internal error</span></div><div class="line">    cout &lt;&lt; reader.GetErrorText(ret);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// is Transponder of standard ISO 15693?</span></div><div class="line">    <span class="keywordflow">if</span>(dynamic_cast&lt;TagHandler::TH_ISO15693*&gt;(pTH) != NULL)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html">TagHandler::TH_ISO15693</a>* pTH_15693 = (<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html">TagHandler::TH_ISO15693</a>*)pTH;</div><div class="line"></div><div class="line">        <span class="comment">// use of casted TagHandler</span></div><div class="line">        cout &lt;&lt; pTH_15693-&gt;<a class="code" href="class_f_e_d_m_1_1_core_1_1_tag_handler_1_1_t_h___i_s_o15693.html#a70cfdfa7c32a50874d54422411f958ec">GetManufacturerName</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">NOTE: reader is an <span class="keywordtype">object</span> of type <a class="code" href="class_f_e_d_m_1_1_core_1_1_reader_module.html">FEDM::Core::ReaderModule</a></div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
		<li class="navelem"><a class="el" href="namespace_f_e_d_m.html">FEDM</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_tag_group.html">ITagGroup</a></li>
		<li class="footer">
<!--			Generated on Wed May 26 2021 10:43:48 for FEDM for C++ by
			<a href="http://www.doxygen.org/index.html">
				<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>-->
			C++ Class-Library FEDM  --  Copyright &copy 2000-2019 by FEIG ELECTRONIC GmbH  
			<a href="http://www.feig.de/en/home.html">
				<img class="footer" src="../images/feig_61x31.jpg" alt="www.feig.de"/>
			</a>	
<!--			1.8.13-->
		</li>
	</ul>
</div>
</body>
</html>
