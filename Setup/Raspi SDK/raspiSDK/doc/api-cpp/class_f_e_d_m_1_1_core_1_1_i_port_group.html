<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>FEDM for C++: FEDM::Core::IPortGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="identification.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FEDM for C++
   &#160;<span id="projectnumber">5.6.0 from 2021-05-21</span>
   </div>
   <div id="projectbrief">Class Library for IDENTIFICATION RFID-Readers, manufactured by FEIG ELECTRONIC GmbH</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_f_e_d_m_1_1_core_1_1_i_port_group.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_f_e_d_m_1_1_core_1_1_i_port_group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEDM::Core::IPortGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal class providing communication port specific commands.  
 <a href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group_1_1_serial_port_setting.html">SerialPortSetting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa094c9c1f3a136b3c307d2ecfb5671ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ce">TcpState</a> { <br />
&#160;&#160;<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea0b73dc1e44bd51aaab4eae77d8805412">CLOSED</a> = 1, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ceab965f68b90bce32886778aaab21290fc">LISTEN</a> = 2, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea26b1af46819bec29a71652775a6232f5">SYN_SEND</a> = 3, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea4ef2fa9dd661695317f0b8293568fcb4">SYN_RCVD</a> = 4, 
<br />
&#160;&#160;<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ceaf6d5513476f0c57f6efeae51950638d4">ESTABLISHED</a> = 5, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea19a90c80c91ed5c3977e252b63f095c4">FIN_WAIT1</a> = 6, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea02f36cf5a943ea2cbc86932710519f4b">FIN_WAIT2</a> = 7, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ceae9898b75ca426a99176ee1f72460088b">CLOSE_WAIT</a> = 8, 
<br />
&#160;&#160;<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea5573baca8c9113ddeca3097d0dea88b3">CLOSING</a> = 9, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671cea3fbe51418babf8669859183bf81241af">LAST_ACK</a> = 10, 
<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ceaa0875d6bbbe6ab22fd1fd8dc5d66c953">TIME_WAIT</a> = 11
<br />
 }<tr class="memdesc:aa094c9c1f3a136b3c307d2ecfb5671ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace with all TCP connection states according RFC 793 (Transmission Control Protocol)  <a href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ce">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa094c9c1f3a136b3c307d2ecfb5671ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6be4811498ea90ad113bc849c2d7ba"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a3d6be4811498ea90ad113bc849c2d7ba">CB_FIND_BAUDRATE</a>) (void *, int, unsigned char, char *, char *, int)</td></tr>
<tr class="memdesc:a3d6be4811498ea90ad113bc849c2d7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of callback function for <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a41cf8465dafead5fdd9e05974f105f0f">FindBaudrate</a>.  <a href="#a3d6be4811498ea90ad113bc849c2d7ba">More...</a><br /></td></tr>
<tr class="separator:a3d6be4811498ea90ad113bc849c2d7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af13420c6e207a6e58b5faa666ae95546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#af13420c6e207a6e58b5faa666ae95546">SetTimeout</a> (unsigned int uiTimeout)</td></tr>
<tr class="memdesc:af13420c6e207a6e58b5faa666ae95546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting communication timeout for Serial Port, USB, Bluetooth, LAN or WLAN.  <a href="#af13420c6e207a6e58b5faa666ae95546">More...</a><br /></td></tr>
<tr class="separator:af13420c6e207a6e58b5faa666ae95546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae188c3c9d4bcb379ebe8296865c767c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ae188c3c9d4bcb379ebe8296865c767c4">SetPortPara</a> (std::string sPara, std::string sValue)</td></tr>
<tr class="memdesc:ae188c3c9d4bcb379ebe8296865c767c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting port parameters for Serial Port, USB, Bluetooth, LAN or WLAN.  <a href="#ae188c3c9d4bcb379ebe8296865c767c4">More...</a><br /></td></tr>
<tr class="separator:ae188c3c9d4bcb379ebe8296865c767c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a78ab5cf8854a45416732d0b670d0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a64a78ab5cf8854a45416732d0b670d0c">SetPortPara</a> (std::string sPara, int iValue)</td></tr>
<tr class="memdesc:a64a78ab5cf8854a45416732d0b670d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting port parameters for Serial Port, USB, Bluetooth, LAN or WLAN.  <a href="#a64a78ab5cf8854a45416732d0b670d0c">More...</a><br /></td></tr>
<tr class="separator:a64a78ab5cf8854a45416732d0b670d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496dc5599b99c277856e4b8160ed61a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7496dc5599b99c277856e4b8160ed61a">GetPortPara</a> (std::string sPara, std::string &amp;sValue)</td></tr>
<tr class="memdesc:a7496dc5599b99c277856e4b8160ed61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port parameter of Serial Port, USB, Bluetooth, LAN or WLAN.  <a href="#a7496dc5599b99c277856e4b8160ed61a">More...</a><br /></td></tr>
<tr class="separator:a7496dc5599b99c277856e4b8160ed61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0886ac6b68addeb15949c31ff75cf2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac0886ac6b68addeb15949c31ff75cf2f">GetPortPara</a> (std::string sPara, int *iValue)</td></tr>
<tr class="memdesc:ac0886ac6b68addeb15949c31ff75cf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port parameter of Serial Port, USB, Bluetooth, LAN or WLAN.  <a href="#ac0886ac6b68addeb15949c31ff75cf2f">More...</a><br /></td></tr>
<tr class="separator:ac0886ac6b68addeb15949c31ff75cf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcebb3b6b5273609a91f32b4c28a80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a5fcebb3b6b5273609a91f32b4c28a80f">GetPortHandle</a> ()</td></tr>
<tr class="memdesc:a5fcebb3b6b5273609a91f32b4c28a80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual used port handle.  <a href="#a5fcebb3b6b5273609a91f32b4c28a80f">More...</a><br /></td></tr>
<tr class="separator:a5fcebb3b6b5273609a91f32b4c28a80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb06cf903bc3b2e7882cd825a3c3dd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a2cb06cf903bc3b2e7882cd825a3c3dd0">SetPortHandle</a> (unsigned int uiPortHnd)</td></tr>
<tr class="memdesc:a2cb06cf903bc3b2e7882cd825a3c3dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new port handle (do not use in normal conditions)  <a href="#a2cb06cf903bc3b2e7882cd825a3c3dd0">More...</a><br /></td></tr>
<tr class="separator:a2cb06cf903bc3b2e7882cd825a3c3dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2dc2cb1157853691cef0aca1f6bdef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a5e2dc2cb1157853691cef0aca1f6bdef">SetProtocolFrameSupport</a> (unsigned int uiType)</td></tr>
<tr class="memdesc:a5e2dc2cb1157853691cef0aca1f6bdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the protocol frame.  <a href="#a5e2dc2cb1157853691cef0aca1f6bdef">More...</a><br /></td></tr>
<tr class="separator:a5e2dc2cb1157853691cef0aca1f6bdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72227d82c659c02eb94fb17fdc8d8f57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a72227d82c659c02eb94fb17fdc8d8f57">GetProtocolFrameSupport</a> ()</td></tr>
<tr class="memdesc:a72227d82c659c02eb94fb17fdc8d8f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual used protocol frame.  <a href="#a72227d82c659c02eb94fb17fdc8d8f57">More...</a><br /></td></tr>
<tr class="separator:a72227d82c659c02eb94fb17fdc8d8f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c7b0664b8cda7f7a04eafe4488141e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ae0c7b0664b8cda7f7a04eafe4488141e">SetBusAddress</a> (unsigned char ucBusAdr)</td></tr>
<tr class="memdesc:ae0c7b0664b8cda7f7a04eafe4488141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bus address for communication over Serial Port.  <a href="#ae0c7b0664b8cda7f7a04eafe4488141e">More...</a><br /></td></tr>
<tr class="separator:ae0c7b0664b8cda7f7a04eafe4488141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb726283ff0c8ded60f555315b2e17c"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#accb726283ff0c8ded60f555315b2e17c">GetBusAddress</a> ()</td></tr>
<tr class="memdesc:accb726283ff0c8ded60f555315b2e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual used bus address, initialized in the Reader class.  <a href="#accb726283ff0c8ded60f555315b2e17c">More...</a><br /></td></tr>
<tr class="separator:accb726283ff0c8ded60f555315b2e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa091ed56f215abdabb20200477eea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4aa091ed56f215abdabb20200477eea9">SetPortPrefix</a> (std::string sPrefix)</td></tr>
<tr class="memdesc:a4aa091ed56f215abdabb20200477eea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Linux: Set the prefix for the Serial Port.  <a href="#a4aa091ed56f215abdabb20200477eea9">More...</a><br /></td></tr>
<tr class="separator:a4aa091ed56f215abdabb20200477eea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3977873f1707ec9f5751efe8024f4f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a3977873f1707ec9f5751efe8024f4f01">ConnectCOMM</a> (unsigned int uiPortNr, bool bWithDetect=true, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group_1_1_serial_port_setting.html">SerialPortSetting</a> *pPortPara=NULL)</td></tr>
<tr class="memdesc:a3977873f1707ec9f5751efe8024f4f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a Serial Port for plain data transmission.  <a href="#a3977873f1707ec9f5751efe8024f4f01">More...</a><br /></td></tr>
<tr class="separator:a3977873f1707ec9f5751efe8024f4f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9161878dfacbb5f5e2ffd3bc0097c106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a9161878dfacbb5f5e2ffd3bc0097c106">ConnectCOMM</a> (unsigned int uiPortNr, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group_1_1_serial_port_setting.html">SerialPortSetting</a> *pPortPara, unsigned int uiAuthentType, std::string sAuthentKey)</td></tr>
<tr class="memdesc:a9161878dfacbb5f5e2ffd3bc0097c106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a Serial Port for secured data transmission.  <a href="#a9161878dfacbb5f5e2ffd3bc0097c106">More...</a><br /></td></tr>
<tr class="separator:a9161878dfacbb5f5e2ffd3bc0097c106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0986fa72fd71a86fb4305ccab47d7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7e0986fa72fd71a86fb4305ccab47d7f">ConnectBT</a> (unsigned int uiPortNumber)</td></tr>
<tr class="memdesc:a7e0986fa72fd71a86fb4305ccab47d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linux: Opens a Bluetooth port and detects (optional) a reader. Windows: Not recommended. Use connectCOMM.  <a href="#a7e0986fa72fd71a86fb4305ccab47d7f">More...</a><br /></td></tr>
<tr class="separator:a7e0986fa72fd71a86fb4305ccab47d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b33275e73e4f57c46d9996d63946c50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4b33275e73e4f57c46d9996d63946c50">InitUnitTest</a> (void)</td></tr>
<tr class="memdesc:a4b33275e73e4f57c46d9996d63946c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a connection to the unit-test reader-emulator.  <a href="#a4b33275e73e4f57c46d9996d63946c50">More...</a><br /></td></tr>
<tr class="separator:a4b33275e73e4f57c46d9996d63946c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44060dccf482acbaf8afe24facd0bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac44060dccf482acbaf8afe24facd0bc3">ConnectTCP</a> (std::string sHostAdr, unsigned int uiPortNr)</td></tr>
<tr class="memdesc:ac44060dccf482acbaf8afe24facd0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a connection to a TCP-Reader for plain data transmission.  <a href="#ac44060dccf482acbaf8afe24facd0bc3">More...</a><br /></td></tr>
<tr class="separator:ac44060dccf482acbaf8afe24facd0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2821cbcb8008c0436a8a110db9f08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a8be2821cbcb8008c0436a8a110db9f08">ConnectTCP</a> (std::string sHostAdr, unsigned int uiPortNr, unsigned int uiAuthentType, std::string sAuthentKey)</td></tr>
<tr class="memdesc:a8be2821cbcb8008c0436a8a110db9f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a connection to a TCP-Reader for secured data transmission.  <a href="#a8be2821cbcb8008c0436a8a110db9f08">More...</a><br /></td></tr>
<tr class="separator:a8be2821cbcb8008c0436a8a110db9f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d87f6d26f90bac9581d8daaaee325e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7d87f6d26f90bac9581d8daaaee325e1">ConnectUSB</a> (unsigned long ulDeviceID)</td></tr>
<tr class="memdesc:a7d87f6d26f90bac9581d8daaaee325e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a connection to an USB-Reader for plain data transmission.  <a href="#a7d87f6d26f90bac9581d8daaaee325e1">More...</a><br /></td></tr>
<tr class="separator:a7d87f6d26f90bac9581d8daaaee325e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcf9e377253b247b95453adffdc1fb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a0dcf9e377253b247b95453adffdc1fb3">ConnectUSB</a> (unsigned long ulDeviceID, unsigned int uiAuthentType, std::string sAuthentKey)</td></tr>
<tr class="memdesc:a0dcf9e377253b247b95453adffdc1fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to open a connection to an USB-Reader for secured data transmission.  <a href="#a0dcf9e377253b247b95453adffdc1fb3">More...</a><br /></td></tr>
<tr class="separator:a0dcf9e377253b247b95453adffdc1fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f5e833d857eb1f2a42d16967509c9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a05f5e833d857eb1f2a42d16967509c9b">DisConnect</a> ()</td></tr>
<tr class="memdesc:a05f5e833d857eb1f2a42d16967509c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a connection.  <a href="#a05f5e833d857eb1f2a42d16967509c9b">More...</a><br /></td></tr>
<tr class="separator:a05f5e833d857eb1f2a42d16967509c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4708207c66aa2dc4700c4b4d80dfef3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4708207c66aa2dc4700c4b4d80dfef3b">IsConnected</a> ()</td></tr>
<tr class="memdesc:a4708207c66aa2dc4700c4b4d80dfef3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connection state.  <a href="#a4708207c66aa2dc4700c4b4d80dfef3b">More...</a><br /></td></tr>
<tr class="separator:a4708207c66aa2dc4700c4b4d80dfef3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf8465dafead5fdd9e05974f105f0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a41cf8465dafead5fdd9e05974f105f0f">FindBaudrate</a> (bool *pStop=NULL, int iTimeout=300, int iFrameSupport=3, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a3d6be4811498ea90ad113bc849c2d7ba">CB_FIND_BAUDRATE</a> cbFct=NULL, void *pAny=NULL)</td></tr>
<tr class="memdesc:a41cf8465dafead5fdd9e05974f105f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only for Serial Port: method to find the baudrate and frame of reader.  <a href="#a41cf8465dafead5fdd9e05974f105f0f">More...</a><br /></td></tr>
<tr class="separator:a41cf8465dafead5fdd9e05974f105f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702c14ffb410c228bef03cbbf21becb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a702c14ffb410c228bef03cbbf21becb6">GetTcpConnectionState</a> ()</td></tr>
<tr class="memdesc:a702c14ffb410c228bef03cbbf21becb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check the actual TCP/IP connection state according RFC 793 (Transmission Control Protocol)  <a href="#a702c14ffb410c228bef03cbbf21becb6">More...</a><br /></td></tr>
<tr class="separator:a702c14ffb410c228bef03cbbf21becb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a6d1511327b4e047781e238d56484e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac3a6d1511327b4e047781e238d56484e">ReaderAuthentication</a> (unsigned int uiAuthentType, std::string sAuthentKey)</td></tr>
<tr class="memdesc:ac3a6d1511327b4e047781e238d56484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to execute an authentication process for secured data transmission.  <a href="#ac3a6d1511327b4e047781e238d56484e">More...</a><br /></td></tr>
<tr class="separator:ac3a6d1511327b4e047781e238d56484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab5df122f02c1a668ab5b470c615d619e"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ab5df122f02c1a668ab5b470c615d619e">PROTOCOL_FRAME_STANDARD</a> = FEDM_PRT_FRAME_STANDARD</td></tr>
<tr class="memdesc:ab5df122f02c1a668ab5b470c615d619e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for Standard Protocol Frame, used for Reader protocol (deprecated, use only for older Readers)  <a href="#ab5df122f02c1a668ab5b470c615d619e">More...</a><br /></td></tr>
<tr class="separator:ab5df122f02c1a668ab5b470c615d619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4ebfe61b67c3a8f621b940adf1cb28"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4a4ebfe61b67c3a8f621b940adf1cb28">PROTOCOL_FRAME_ADVANCED</a> = FEDM_PRT_FRAME_ADVANCED</td></tr>
<tr class="memdesc:a4a4ebfe61b67c3a8f621b940adf1cb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for Advanced Protocol Frame, used for Reader protocol (ADVANCED frame should be used with actual Readers)  <a href="#a4a4ebfe61b67c3a8f621b940adf1cb28">More...</a><br /></td></tr>
<tr class="separator:a4a4ebfe61b67c3a8f621b940adf1cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bab0e86ef03be04ec72dffcc8d07c"><td class="memItemLeft" align="right" valign="top"><a id="a864bab0e86ef03be04ec72dffcc8d07c"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a864bab0e86ef03be04ec72dffcc8d07c">TRANSMISSION_PLAIN</a> = 255</td></tr>
<tr class="memdesc:a864bab0e86ef03be04ec72dffcc8d07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for plain protocol transmission (standard) <br /></td></tr>
<tr class="separator:a864bab0e86ef03be04ec72dffcc8d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd46a859ab9ffa6b264e65f7b266a91"><td class="memItemLeft" align="right" valign="top"><a id="a7dd46a859ab9ffa6b264e65f7b266a91"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a7dd46a859ab9ffa6b264e65f7b266a91">TRANSMISSION_AES128</a> = 0</td></tr>
<tr class="memdesc:a7dd46a859ab9ffa6b264e65f7b266a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for secured protocol transmission to select the Advanced Encryption Standard (AES) with 128 bit key length. <br /></td></tr>
<tr class="separator:a7dd46a859ab9ffa6b264e65f7b266a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db04689bb69093d7d93c6654f67e8ea"><td class="memItemLeft" align="right" valign="top"><a id="a0db04689bb69093d7d93c6654f67e8ea"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a0db04689bb69093d7d93c6654f67e8ea">TRANSMISSION_AES192</a> = 1</td></tr>
<tr class="memdesc:a0db04689bb69093d7d93c6654f67e8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for secured protocol transmission to select the Advanced Encryption Standard (AES) with 192 bit key length. <br /></td></tr>
<tr class="separator:a0db04689bb69093d7d93c6654f67e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fcaca23eafdf86873154a126863102"><td class="memItemLeft" align="right" valign="top"><a id="a95fcaca23eafdf86873154a126863102"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a95fcaca23eafdf86873154a126863102">TRANSMISSION_AES256</a> = 2</td></tr>
<tr class="memdesc:a95fcaca23eafdf86873154a126863102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for secured protocol transmission to select the Advanced Encryption Standard (AES) with 256 bit key length. <br /></td></tr>
<tr class="separator:a95fcaca23eafdf86873154a126863102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal class providing communication port specific commands. </p>
<p><b>Description</b><br />
 This class realizes the nested interface with special methods for port specific commands for the Reader class <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>.<br />
 Methods of this class can be called with the <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html#ab9a7ef1b446d2ec99bbc0c9751fbee4c">IPort</a> member of <a class="el" href="class_f_e_d_m_1_1_core_1_1_reader_module.html" title="Class ReaderModule is the Reader class. ">ReaderModule</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3d6be4811498ea90ad113bc849c2d7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6be4811498ea90ad113bc849c2d7ba">&#9670;&nbsp;</a></span>CB_FIND_BAUDRATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* FEDM::Core::IPortGroup::CB_FIND_BAUDRATE) (void *, int, unsigned char, char *, char *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of callback function for <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a41cf8465dafead5fdd9e05974f105f0f">FindBaudrate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">void*</td><td>pointer to anything (e.g. 'this' pointer), which is transferred as last parameter in <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a41cf8465dafead5fdd9e05974f105f0f">FindBaudrate</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>Serial Port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unsigned</td><td>char Bus-Address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char*</td><td>Actual selected baudrate ("230400", "115200", "57600", "38400", "19200", "9600", "4800") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char*</td><td>Actual selected frame ("8E1", "8N1", "8O1") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>Actual selected protocol frame (<a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ab5df122f02c1a668ab5b470c615d619e" title="Constant for Standard Protocol Frame, used for Reader protocol (deprecated, use only for older Reader...">PROTOCOL_FRAME_STANDARD</a>, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4a4ebfe61b67c3a8f621b940adf1cb28" title="Constant for Advanced Protocol Frame, used for Reader protocol (ADVANCED frame should be used with ac...">PROTOCOL_FRAME_ADVANCED</a>)</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br />
 Used for rare cases, when e.g. the detection process must be signaled with a Progress Bar or with Messages </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa094c9c1f3a136b3c307d2ecfb5671ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa094c9c1f3a136b3c307d2ecfb5671ce">&#9670;&nbsp;</a></span>TcpState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#aa094c9c1f3a136b3c307d2ecfb5671ce">FEDM::Core::IPortGroup::TcpState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace with all TCP connection states according RFC 793 (Transmission Control Protocol) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea0b73dc1e44bd51aaab4eae77d8805412"></a>CLOSED&#160;</td><td class="fielddoc"><p>represents no connection state at all </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671ceab965f68b90bce32886778aaab21290fc"></a>LISTEN&#160;</td><td class="fielddoc"><p>represents waiting for a connection request from any remote TCP and port </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea26b1af46819bec29a71652775a6232f5"></a>SYN_SEND&#160;</td><td class="fielddoc"><p>represents waiting for a matching connection request after having sent a connection request </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea4ef2fa9dd661695317f0b8293568fcb4"></a>SYN_RCVD&#160;</td><td class="fielddoc"><p>represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671ceaf6d5513476f0c57f6efeae51950638d4"></a>ESTABLISHED&#160;</td><td class="fielddoc"><p>represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea19a90c80c91ed5c3977e252b63f095c4"></a>FIN_WAIT1&#160;</td><td class="fielddoc"><p>represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea02f36cf5a943ea2cbc86932710519f4b"></a>FIN_WAIT2&#160;</td><td class="fielddoc"><p>represents waiting for a connection termination request from the remote TCP </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671ceae9898b75ca426a99176ee1f72460088b"></a>CLOSE_WAIT&#160;</td><td class="fielddoc"><p>represents waiting for a connection termination request from the local user </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea5573baca8c9113ddeca3097d0dea88b3"></a>CLOSING&#160;</td><td class="fielddoc"><p>represents waiting for a connection termination request acknowledgment from the remote TCP </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671cea3fbe51418babf8669859183bf81241af"></a>LAST_ACK&#160;</td><td class="fielddoc"><p>represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa094c9c1f3a136b3c307d2ecfb5671ceaa0875d6bbbe6ab22fd1fd8dc5d66c953"></a>TIME_WAIT&#160;</td><td class="fielddoc"><p>represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af13420c6e207a6e58b5faa666ae95546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13420c6e207a6e58b5faa666ae95546">&#9670;&nbsp;</a></span>SetTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPortGroup::SetTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting communication timeout for Serial Port, USB, Bluetooth, LAN or WLAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiTimeout</td><td>new communication timeout in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br />
 Used for setting the timeout parameter in the underlying libraries FECOM, FEUSB and FETCP<br />
 Use these library manuals to view which parameters and which parameter ranges are applicable </p>

</div>
</div>
<a id="ae188c3c9d4bcb379ebe8296865c767c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae188c3c9d4bcb379ebe8296865c767c4">&#9670;&nbsp;</a></span>SetPortPara() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::SetPortPara </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sPara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting port parameters for Serial Port, USB, Bluetooth, LAN or WLAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sPara</td><td>Parameter Name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sValue</td><td>Parameter Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Used for setting port parameters in the underlying libraries FECOM, FEUSB and FETCP<br />
 Use these library manuals to view which parameters are applicable </p>

</div>
</div>
<a id="a64a78ab5cf8854a45416732d0b670d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a78ab5cf8854a45416732d0b670d0c">&#9670;&nbsp;</a></span>SetPortPara() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::SetPortPara </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sPara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting port parameters for Serial Port, USB, Bluetooth, LAN or WLAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sPara</td><td>Parameter Name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iValue</td><td>Parameter Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Used for setting port parameters in the underlying libraries FECOM, FEUSB and FETCP<br />
 Use these library manuals to view which parameters are applicable </p>

</div>
</div>
<a id="a7496dc5599b99c277856e4b8160ed61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7496dc5599b99c277856e4b8160ed61a">&#9670;&nbsp;</a></span>GetPortPara() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::GetPortPara </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sPara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>sValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a port parameter of Serial Port, USB, Bluetooth, LAN or WLAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sPara</td><td>Parameter Name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sValue</td><td>Parameter Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Used for getting port parameters from the underlying libraries FECOM, FEUSB and FETCP<br />
 Use these library manuals to view which parameters are applicable </p>

</div>
</div>
<a id="ac0886ac6b68addeb15949c31ff75cf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0886ac6b68addeb15949c31ff75cf2f">&#9670;&nbsp;</a></span>GetPortPara() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::GetPortPara </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sPara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a port parameter of Serial Port, USB, Bluetooth, LAN or WLAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sPara</td><td>Parameter Name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iValue</td><td>Parameter Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Used for getting port parameters from the underlying libraries FECOM, FEUSB and FETCP<br />
 Use these library manuals to view which parameters are applicable </p>

</div>
</div>
<a id="a5fcebb3b6b5273609a91f32b4c28a80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcebb3b6b5273609a91f32b4c28a80f">&#9670;&nbsp;</a></span>GetPortHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::GetPortHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the actual used port handle. </p>
<dl class="section return"><dt>Returns</dt><dd>Port Handle (&gt;0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a2cb06cf903bc3b2e7882cd825a3c3dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb06cf903bc3b2e7882cd825a3c3dd0">&#9670;&nbsp;</a></span>SetPortHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::SetPortHandle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortHnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new port handle (do not use in normal conditions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortHnd</td><td>New port handle</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br />
 This method is for special conditions. Do not use it. Use always the Connect methods for your applications. </p>

</div>
</div>
<a id="a5e2dc2cb1157853691cef0aca1f6bdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2dc2cb1157853691cef0aca1f6bdef">&#9670;&nbsp;</a></span>SetProtocolFrameSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::SetProtocolFrameSupport </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the protocol frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiType</td><td>Protocol Frame Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Change the protocol frame type to <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ab5df122f02c1a668ab5b470c615d619e">PROTOCOL_FRAME_STANDARD</a> or <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a4a4ebfe61b67c3a8f621b940adf1cb28">PROTOCOL_FRAME_ADVANCED</a></p>
<dl class="section note"><dt>Note</dt><dd>STANDARD is preset in the library </dd></dl>

</div>
</div>
<a id="a72227d82c659c02eb94fb17fdc8d8f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72227d82c659c02eb94fb17fdc8d8f57">&#9670;&nbsp;</a></span>GetProtocolFrameSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::GetProtocolFrameSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the actual used protocol frame. </p>
<dl class="section return"><dt>Returns</dt><dd>Actually used protocol frame</dd></dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="ae0c7b0664b8cda7f7a04eafe4488141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c7b0664b8cda7f7a04eafe4488141e">&#9670;&nbsp;</a></span>SetBusAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPortGroup::SetBusAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucBusAdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bus address for communication over Serial Port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucBusAdr</td><td>New bus address to be used for the serial communication</td></tr>
  </table>
  </dd>
</dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="accb726283ff0c8ded60f555315b2e17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb726283ff0c8ded60f555315b2e17c">&#9670;&nbsp;</a></span>GetBusAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char IPortGroup::GetBusAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual used bus address, initialized in the Reader class. </p>
<dl class="section return"><dt>Returns</dt><dd>Actually used bus address</dd></dl>
<p><b>Description</b><br />
 </p>

</div>
</div>
<a id="a4aa091ed56f215abdabb20200477eea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa091ed56f215abdabb20200477eea9">&#9670;&nbsp;</a></span>SetPortPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::SetPortPrefix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sPrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For Linux: Set the prefix for the Serial Port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sPrefix</td><td>String with port prefix name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 For Linux, the prefix for e.g. Bluetooth is /dev/rfcomm and not /dev/ttyS The prefix should be set in the eve of ConnectCOMM and should be set back to /dev/ttyS directly after this call. </p>

</div>
</div>
<a id="a3977873f1707ec9f5751efe8024f4f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3977873f1707ec9f5751efe8024f4f01">&#9670;&nbsp;</a></span>ConnectCOMM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectCOMM </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWithDetect</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group_1_1_serial_port_setting.html">SerialPortSetting</a> *&#160;</td>
          <td class="paramname"><em>pPortPara</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a Serial Port for plain data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNr</td><td>Number of serial port in the range of 1...256 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bWithDetect</td><td>if true (preset), a call of FindBaudRate() and <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a> is done to adjust the port parameters and to set the Reader Type Number internally </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPortPara</td><td>optional initialization parameters.<br />
If para is set to null, the following default values will be used: busAddress=0, baudRate=0, frame="8E1", charTimeoutMpy=1 and setRtsAndDtrOn=false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Opens a serial port with Baudrate and Frame adapted to the Reader's port settings.<br />
 If the second parameter is set to false, the port parameters will not be adapted to the Reader's port settings and the Reader cannot not be detetcted. In this case, the application must call FindBaudRate() and <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a> later.<br />
 It is recommended to set bDetect to true, if the Reader is still connected at the correct port and powered-on.</p>
<dl class="section note"><dt>Note</dt><dd>For Linux: use port number 1 for ttyS0 and so forth. </dd></dl>

</div>
</div>
<a id="a9161878dfacbb5f5e2ffd3bc0097c106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9161878dfacbb5f5e2ffd3bc0097c106">&#9670;&nbsp;</a></span>ConnectCOMM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectCOMM </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group_1_1_serial_port_setting.html">SerialPortSetting</a> *&#160;</td>
          <td class="paramname"><em>pPortPara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a Serial Port for secured data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNr</td><td>Number of serial port in the range of 1...256 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPortPara</td><td>optional initialization parameters.<br />
If para is set to null, the following default values will be used: busAddress=0, baudRate=0, frame="8E1", charTimeoutMpy=1 and setRtsAndDtrOn=false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>Type of authentification, when set to a type of FEDM::Core::Const::AES128 or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Opens a serial port with the following calls of FindBaudRate(), <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a> and <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac3a6d1511327b4e047781e238d56484e" title="Method to execute an authentication process for secured data transmission. ">ReaderAuthentication()</a>. Thus, it is expected, that the Reader is connected at the correct port and powered-on.<br />
 If an error occurs or the Reader cannot be detected, the method returns an error code. This method can only be used, if the Reader supports secured data transmission.</p>
<dl class="section note"><dt>Note</dt><dd>For Linux: use port number 1 for ttyS0 and so forth. </dd>
<dd>
: Secured data transmission is not supported with every Reader. Please refer to the Reader's System Manual for additional information.<br />
 </dd></dl>

</div>
</div>
<a id="a7e0986fa72fd71a86fb4305ccab47d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0986fa72fd71a86fb4305ccab47d7f">&#9670;&nbsp;</a></span>ConnectBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectBT </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linux: Opens a Bluetooth port and detects (optional) a reader. Windows: Not recommended. Use connectCOMM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiPortNumber</td><td>the number of the Bluetooth port in the range 1..256 (1 is asigned to /dev/rfcomm0, 2 to /dev/rfcomm1 and so on) </td></tr>
  </table>
  </dd>
</dl>
<p><b>Description:</b><br />
 This method is only for Linux!<br />
 Method opens a Bluetooth port and detects a reader and reads information from reader.<br />
 The Reader must be powered on.<br />
 After successful opening of the Bluetooth port, the reader will be detected with FindBaudRate() method and if with success, the complete reader information is read and can be queried with <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a364ba2ae4e72e6c8132244cf79f87c7d" title="Return structure with previously read Reader information. ">IInfoGroup::GetReaderInfo()</a>.<br />
 In case of not detecting a reader the Bluetooth port is closed again.<br />
 The connect method can be used once for every reader object. If the port must be changed, the opened port must first be closed with the method disConnect.<br />
 </p>

</div>
</div>
<a id="a4b33275e73e4f57c46d9996d63946c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b33275e73e4f57c46d9996d63946c50">&#9670;&nbsp;</a></span>InitUnitTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::InitUnitTest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a connection to the unit-test reader-emulator. </p>
<p><b>Description:</b><br />
 This method is only for FEIG internal Unit-Tests!<br />
 This function sets LR1002 as default reader type. Use SetReaderType() if your test case needs another one. </p>

</div>
</div>
<a id="ac44060dccf482acbaf8afe24facd0bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44060dccf482acbaf8afe24facd0bc3">&#9670;&nbsp;</a></span>ConnectTCP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectTCP </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sHostAdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a connection to a TCP-Reader for plain data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sHostAdr</td><td>TCP/IP-Address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNr</td><td>TCP/IP-Portnumber </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Establish a connection to a TCP-Reader with the following call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a>. Thus, it is expected, that the Reader is connected at the Ethernet and powered-on.<br />
 If an error occurs or the Reader cannot be detected, the method returns an error code. </p>

</div>
</div>
<a id="a8be2821cbcb8008c0436a8a110db9f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be2821cbcb8008c0436a8a110db9f08">&#9670;&nbsp;</a></span>ConnectTCP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectTCP </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sHostAdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiPortNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a connection to a TCP-Reader for secured data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sHostAdr</td><td>TCP/IP-Address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiPortNr</td><td>TCP/IP-Portnumber </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>Type of authentification, when set to a type of FEDM::Core::Const::AES128 or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Establish a connection to a TCP-Reader with the following call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a> and <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac3a6d1511327b4e047781e238d56484e" title="Method to execute an authentication process for secured data transmission. ">ReaderAuthentication()</a>. Thus, it is expected, that the Reader is connected at the Ethernet and powered-on.<br />
 If an error occurs or the Reader cannot be detected, the method returns an error code.</p>
<dl class="section note"><dt>Note</dt><dd>: Secured data transmission is not supported with every Reader. Please refer to the Reader's System Manual for additional information.<br />
 </dd></dl>

</div>
</div>
<a id="a7d87f6d26f90bac9581d8daaaee325e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d87f6d26f90bac9581d8daaaee325e1">&#9670;&nbsp;</a></span>ConnectUSB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectUSB </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulDeviceID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a connection to an USB-Reader for plain data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulDeviceID</td><td>Device-ID of Reader or 0 to connect to the first USB-Reader, which is detected at USB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Open a connection to an USB-Reader with the following call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a>. Thus, it is expected, that the Reader is connected at the USB and powered-on.<br />
 If an error occurs or the Reader cannot be detected, the method returns an error code.<br />
 If only one USB-Reader is connected at the System, the Device-ID can be set to 0.<br />
 If multiple USB-Readers are connected, the Device-IDs must be requested with the USB-Library FEUSB. If a 0 ist unsed instead, it is not guaranteed to connect always to the same USB-Reader. </p>

</div>
</div>
<a id="a0dcf9e377253b247b95453adffdc1fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcf9e377253b247b95453adffdc1fb3">&#9670;&nbsp;</a></span>ConnectUSB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ConnectUSB </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulDeviceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to open a connection to an USB-Reader for secured data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulDeviceID</td><td>Device-ID of Reader or 0 to connect to the first USB-Reader, which is detected at USB </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>Type of authentification, when set to a type of FEDM::Core::Const::AES128 or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 Open a connection to an USB-Reader with the following call of <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_info_group.html#a42a01ce2283d160b33fef0900c40dd23" title="Read complete reader info and set the Reader Type. ">IInfoGroup::ReadReaderInfo()</a> and <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#ac3a6d1511327b4e047781e238d56484e" title="Method to execute an authentication process for secured data transmission. ">ReaderAuthentication()</a>. Thus, it is expected, that the Reader is connected at the USB and powered-on.<br />
 If an error occurs or the Reader cannot be detected, the method returns an error code.<br />
 If only one USB-Reader is connected at the System, the Device-ID can be set to 0.<br />
 If multiple USB-Readers are connected, the Device-IDs must be requested with the USB-Library FEUSB. If a 0 ist unsed instead, it is not guaranteed to connect always to the same USB-Reader.</p>
<dl class="section note"><dt>Note</dt><dd>: Secured data transmission is not supported with every Reader. Please refer to the Reader's System Manual for additional information.<br />
 </dd></dl>

</div>
</div>
<a id="a05f5e833d857eb1f2a42d16967509c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f5e833d857eb1f2a42d16967509c9b">&#9670;&nbsp;</a></span>DisConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::DisConnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a connection. </p>
<dl class="section return"><dt>Returns</dt><dd>OK (=0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 Close the existing connection. When closing a TCP/IP connection, the last status of the connection is returned. But if the status TIME_WAIT is detected, a 0 will be returned to signal a successful disconnection. Otherwise, <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a702c14ffb410c228bef03cbbf21becb6" title="Method to check the actual TCP/IP connection state according RFC 793 (Transmission Control Protocol) ...">GetTcpConnectionState()</a> should be called again to observe the TCP/IP connection status. </p>

</div>
</div>
<a id="a4708207c66aa2dc4700c4b4d80dfef3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4708207c66aa2dc4700c4b4d80dfef3b">&#9670;&nbsp;</a></span>IsConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPortGroup::IsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connection state. </p>
<dl class="section return"><dt>Returns</dt><dd>true, if a Connect method was previously successfully called</dd></dl>
<p><b>Description</b><br />
 Signals that the application has called one of the Connect methods and no further connection can be established. It is not active checked (e.g. with a Reader command), if the Reader is still connected and a communication is possible </p>

</div>
</div>
<a id="a41cf8465dafead5fdd9e05974f105f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cf8465dafead5fdd9e05974f105f0f">&#9670;&nbsp;</a></span>FindBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::FindBaudrate </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pStop</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTimeout</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iFrameSupport</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a3d6be4811498ea90ad113bc849c2d7ba">CB_FIND_BAUDRATE</a>&#160;</td>
          <td class="paramname"><em>cbFct</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAny</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only for Serial Port: method to find the baudrate and frame of reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStop</td><td>Do not change the preset! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iTimeout</td><td>Do not change the preset! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iFrameSupport</td><td>Do not change the preset! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbFct</td><td>Do not change the preset! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAny</td><td>Do not change the preset! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
 The serial port settings will be adjusted to the port settings of the connected and powered-on Reader. All parameters are for special cases and should not be changed. </p>

</div>
</div>
<a id="a702c14ffb410c228bef03cbbf21becb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702c14ffb410c228bef03cbbf21becb6">&#9670;&nbsp;</a></span>GetTcpConnectionState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::GetTcpConnectionState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to check the actual TCP/IP connection state according RFC 793 (Transmission Control Protocol) </p>
<dl class="section return"><dt>Returns</dt><dd>Connection status (&gt;0) or <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a> (&lt;0)</dd></dl>
<p><b>Description</b><br />
 When closing a TCP/IP connection, the last status of the connection is returned. If the status is not TIME_WAIT, GetTcpConnectionState() should be called to observe the TCP/IP connection status, because a new connection to the same Reader is only possible after the connection state TIME_WAIT is reached.<br />
 <br />
 The following connection states are defined: </p><pre>
    CLOSED               1
    LISTEN               2
    SYN_SENT             3
    SYN_RCVD             4
    ESTABLISHED          5
    FIN_WAIT1            6
    FIN_WAIT2            7
    CLOSE_WAIT           8
    CLOSING              9
    LAST_ACK            10
    TIME_WAIT           11
</pre> 
</div>
</div>
<a id="ac3a6d1511327b4e047781e238d56484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a6d1511327b4e047781e238d56484e">&#9670;&nbsp;</a></span>ReaderAuthentication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPortGroup::ReaderAuthentication </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uiAuthentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sAuthentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to execute an authentication process for secured data transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiAuthentType</td><td>Type of authentification, when set to a type of FEDM::Core::Const::AES128 or higher </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sAuthentKey</td><td>Authentification password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if OK</li>
<li>&lt; 0 <a class="el" href="class_f_e_d_m_1_1_core_1_1_error_code.html">error code</a></li>
<li>&gt; 0 status byte of the responded protocol, if the Reader signals a problem. See Reader's System Manual for the full list with all status bytes.</li>
</ul>
</dd></dl>
<p><b>Description</b><br />
</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be used, if the Reader supports secured data transmission. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab5df122f02c1a668ab5b470c615d619e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5df122f02c1a668ab5b470c615d619e">&#9670;&nbsp;</a></span>PROTOCOL_FRAME_STANDARD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int FEDM::Core::IPortGroup::PROTOCOL_FRAME_STANDARD = FEDM_PRT_FRAME_STANDARD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant for Standard Protocol Frame, used for Reader protocol (deprecated, use only for older Readers) </p>
<dl class="section note"><dt>Note</dt><dd>By default, the protocol frame is set to Standard </dd></dl>

</div>
</div>
<a id="a4a4ebfe61b67c3a8f621b940adf1cb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4ebfe61b67c3a8f621b940adf1cb28">&#9670;&nbsp;</a></span>PROTOCOL_FRAME_ADVANCED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int FEDM::Core::IPortGroup::PROTOCOL_FRAME_ADVANCED = FEDM_PRT_FRAME_ADVANCED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant for Advanced Protocol Frame, used for Reader protocol (ADVANCED frame should be used with actual Readers) </p>
<dl class="section note"><dt>Note</dt><dd>By default, the protocol frame is set to Standard. Use the method <a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html#a5e2dc2cb1157853691cef0aca1f6bdef" title="Change the protocol frame. ">IPortGroup::SetProtocolFrameSupport()</a> to switch to Advanced Protocol </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
		<li class="navelem"><a class="el" href="namespace_f_e_d_m.html">FEDM</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="class_f_e_d_m_1_1_core_1_1_i_port_group.html">IPortGroup</a></li>
		<li class="footer">
<!--			Generated on Wed May 26 2021 10:43:47 for FEDM for C++ by
			<a href="http://www.doxygen.org/index.html">
				<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>-->
			C++ Class-Library FEDM  --  Copyright &copy 2000-2019 by FEIG ELECTRONIC GmbH  
			<a href="http://www.feig.de/en/home.html">
				<img class="footer" src="../images/feig_61x31.jpg" alt="www.feig.de"/>
			</a>	
<!--			1.8.13-->
		</li>
	</ul>
</div>
</body>
</html>
